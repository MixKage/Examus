package com.example.osexamen

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.MotionEvent
import android.view.View
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity


class Test : AppCompatActivity() {
    private var answer = arrayOfNulls<String>(40)
    private var quest = arrayOfNulls<String>(40)
    private var count = 0
    private var questInt = arrayOfNulls<Int>(10)
    private var doubleclick = false
    private lateinit var button: Button
    private lateinit var label1: TextView
    private lateinit var textBox1: TextView
    private lateinit var textBox2: TextView
    private lateinit var photobox: ImageView

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportActionBar?.hide()
        GenerateQuestAnswer()
        setContentView(R.layout.activity_test)
        button = findViewById(R.id.button)
        label1 = findViewById(R.id.label1)
        textBox1 = findViewById(R.id.textBox1)
        textBox2 = findViewById(R.id.textBox2)
        photobox = findViewById(R.id.imageView)

        button.setOnTouchListener(object : View.OnTouchListener {
            override fun onTouch(v: View?, event: MotionEvent?): Boolean {
                if (event!!.action == MotionEvent.ACTION_DOWN)
                    button.alpha = 0.7f
                else if (event.action == MotionEvent.ACTION_UP)
                    button.alpha = 1f
                return false
            }
        })

        button.setOnClickListener()
        {
            ButtonClick()
        }
    }

    @SuppressLint("SetTextI18n")
    fun FirstClick() {
        photobox.setImageDrawable(null)
        label1.text = "Вопрос " + (count + 1)
        button.text = "Answer"
        var temp = (0..39).random()
        while (temp in questInt)
            temp = (0..39).random()

        questInt[count] = temp
        textBox2.text = ""
        textBox1.text = quest[temp]
        doubleclick = true
    }

    @SuppressLint("SetTextI18n")
    fun SecondClick() {
        if (questInt[count] == 11) {
            photobox.setImageResource(R.drawable.p11)
        } else if (questInt[count] == 15) {
            photobox.setImageResource(R.drawable.p15)
        } else if (questInt[count] == 29) {
            photobox.setImageResource(R.drawable.p29)
        }
        button.text = "Question"
        textBox2.text = "Вопрос: " + quest[questInt[count]!!]
        textBox1.text = "\n\nОтвет: " + answer[questInt[count]!!]
        count++
        doubleclick = false
        if (count == 10) {
            button.text = "Exit"
        }
    }

    fun ButtonClick() {
        if (count == 10) {
            count = 0
            this.finish()
        } else {
            if (doubleclick)
                SecondClick()
            else
                FirstClick()
        }
    }

    fun GenerateQuestAnswer() {
        answer[0] =
            "На 0 уровне находится аппаратное обеспечение. Этот уровень воспринимает ТОЛЬКО команды\nмашинного языка. На 1 уровне находится микроархитектура.На этом уровне можно работать с\nсовокупностью регистров, разрядность которых на текущий момент х32 или х64, и АЛУ. 2 уровень\nсоставляет уровень архитектуры системы команд. На этом уровне уже могут выполняться машинные\nкоманды ассемблера. 3 уровень – гибридный.На нем и находится ОС, которая позволяет выполнять\nсистемные вызовы, макросы или работать в режиме super визора.Все следующие уровни\nпредназначены для прикладных программистов."
        answer[1] =
            "Принципиально важными и универсальными подходами к разработке архитектуры ОС являются:\n1. Модульная организация;\n2. Функциональная избыточность;\n3. Функциональная избирательность;\n4. Параметрическая универсальность;\n5. Концепция многоуровневой иерархической вычислительной системы;\n6. Разделение модулей на два группы: ядро и пользовательские;\n7. Разделение модулей по размещению в памяти на резидентные и транзитные;\n8. Реализация двух режимов работы: user mode и kernel mode;\n9. Ограничение функций ядра.\nВ любой ОС количество модулей User mode всегда больше, чем количество модулей Kernel mode.\nПрограммы с приоритетом “0” выполняются на уровне Kernel mode. В kernel должно быть как можно\nменьше модулей. "
        answer[2] =
            "1. Наноядро – крайне упрощенное и минимальное ядро, которое выполняет только 1 задачу –\nобработку аппаратных прерываний (предназначено для управления простейшими техническими объектами, такими как умные карты или умные ключи для автомобилей)\n2. Микроядро – представляет собой элементарные функции управления процессами и\nминимальный набор абстракций для работы с оборудованием (предназначено для управления дата-центрами, оно не способно даже на примитивный уровень защиты)\n3. Экзоядро – представляет собой набор сервисов для взаимодействия между приложениями\n(также предназначено для управления сложными техническими объектами, которые требуют\nотклика за строго отведенное время, например разведение мостов, управление атомной\nстанции; на этом ядре работают операционные системы реального времени)\n4. Монолитное ядро – представляет собой широкий набор абстракций, все части ядра работают\nв одном адресном пространстве (используется в настоящее время в ОС, которые\nобслуживают микрокомпьютеры, каждая сборка работает на строго отведенном\nоборудовании и в случае изменения аппаратной конфигурации требуется полная пересборка всего ядра; в случае с монолитным ядром чаще всего вся ОС может содержаться в оперативной памяти, не используя для этого отдельный жесткий диск)\n5. Модульное ядро – современное, усовершенствованная модификация монолитного ядра, в\nотличие от классических монолитных ядер не требует полной перекомпиляции при\n        изменении состава аппаратного обеспечения (предназначено для большинства современных ОС; при использовании модульного ядра основное требование заключается в том, чтобы\nнаследники отвечали тем же требованиям, что и существующий модуль)\n6. Гибридное ядро – модифицированное микроядро, позволяющее запускать несущественные\nчасти в пространстве ядра (работает по тому же принципу, что и модульное ядро)\n7. Второе гибридное ядро – наиболее тесно связаны элементы микроядерной архитектуры и\nэлементы монолитного ядра (в настоящее время второе гибридное ядро не используется)"
        answer[3] =
            "1. Эффективность. Эффективность ОС оценивается как количество выполненных\nпользовательских задач к общему количеству выполненных задач за один квант времени;\n2. Надежность и отказоустойчивость считается как количество событий, пришедших к краху\nОС к общему количеству ошибок за один квант времени; 3. Безопасность ОС считается как количество успешно отраженных атак к общему количеству\nатак за один квант времени. Kali Linux – система для тестирования безопасности;\n4. Предсказуемость ОС — это количество одинаково выполненных задач к общему количеству\nзадач за один квант времени;\n5. Расширяемость ОС – количество модулей, которые потенциально можно добавить к общему\nколичеству модулей;\n6. Переносимость ОС – количество устройств, на которых она может работать без\nдополнительной настройки общему количеству устройств;\n7. Совместимость (коэффициент) есть количество приложений, которые она потенциально\nможет выполнить к общему количеству приложений;\n8. Удобство ОС есть коэффициент количества спрогнозированных самим пользователем действий к общему количеству действий;\n9. Масштабируемость – количество корректно используемого оборудования к общему\nколичеству оборудования в рамках одной конфигурации."
        answer[4] =
            "Процесс – абстрактное понятие, описывающих работу программы. Всё функционирующее на\nкомпьютере ПО, включая саму ОС, можно представить набором процессов. Процесс\nрассматривается ОС как заявка или контейнер для всех видов ресурсов, кроме процессорного\nвремени. Этот ресурс распределяется ОС между другими единицами работы – потоками, которые\nпредставляют собой последовательность или поток выполнения определенных команд.\nЕсли основной поток часто появляется в очереди на обработку и при этом с ним ничего не\n        происходит, ОС считает зависшим такой поток и его процесс.\nДлительные действия с точки зрения процесса всегда должны выполняться отдельными потоками. Работа основного потока в ОС не должна сильно страдать, если не выполняется работа\nдочерних потоков.\nКаждый процесс должен считать себя уникальным в оперативной памяти. Прямой доступ к\nоперативной памяти другого процесса – нарушение условий функционирования и безопасности с\nточки зрения ОС.\nС точки зрения процесса, инкапсуляция – защита оперативной памяти самого процесса и\nпредоставление методов для работы с ней.\nНаследование, с точки зрения процессов – создание отдельных процессов для выполнения\nкаких-либо задач и закрепления родителя.\nКорректная модель наследования требует, чтобы любой процесс, порожденный от другого\nпроцесса, являлся его наследником. В противном случае не реализуется один из базовых\nмеханизмов операционной системы.\nПолиморфизм, с точки зрения процессов, реализуется как возможность работать как с\nодним типом параметров, так и с другим.\nВзаимоисключение (когда 2 процесса, обратившись к ресурсу и не получив доступа, должны быть оба остановлены одновременно или остановлен только один)\nМетоды взаимоисключений\nДля организации взаимоисключений критических участков существует 5 основных условий,\nкоторые должны выполняться для каждого процесса:\n1. Задача должна быть решена чисто программным способом на обычной машине, не\nимеющей специальных команд взаимоисключения;\n2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов, потому что этот процесс слишком непредсказуем;\n3. Если процесс, выполняется в своем критическом участке, то не должно существовать\nдругих процессов, которые выполняются в подобных критических участках;\n4. Процессы, которые находятся вне своих критических участков и не собираются в них\nвходить, не должны препятствовать другим процессам входить в их критические участки;\n5. Не должно возникать бесконечного ожидания для входа в свой критический участок.\nОС единообразно работает со всеми неразделяемыми ресурсами, а любое физическое устройство\n– это чаще всего неразделяемый ресурс."
        answer[5] =
            "Подсистема управления процессами и потоками - основная подсистема в современных ОС. Ее\nосновные функции:\n1. Создание процессов и потоков; 2. Обеспечение процессов и потоков необходимыми ресурсами;\n3. Изоляция процессов. С точки зрения изоляции процессов, общение процессов напрямую без\nиспользования API операционной системы, является нарушением безопасности в рамках ОС.\nЕсли процессы начинают общаться между собой без использования API ОС, то они могут\nнапрямую общаться с ресурсами и менеджерами ресурсов в рамках данного процесса, что\nявляется нарушением безопасности ОС;\n4. Планирование выполнения процессов и потоков;\n5. Диспетчеризация процессов и потоков – сравнение запланированных задач и выполненных. В  ОС существуют транзакционное выполнение потоков, в этом случае поток должен\nвыполниться до определенной точки, если этого не происходит, ОС откатывает состояние\nпотока в первоначальное и повторяет попытку выполнения;\n6. Организация межпроцессного взаимодействия;\n7. Синхронизация процессов и потоков;\n8. Завершение процессов и потоков.\nТупиковая ситуация (взаимоблокировка) – когда два и более процесса удерживают и бесконечно\nожидают необходимые для выполнения ресурсов. Для возникновения такой ситуации необходимо\nвыполнение одновременно 4 условий:\n1. Условия взаимного исключения;\n2. Условия удержания и ожидания;\n3. Условие отсутствия принудительной выгрузки ресурсов;\n4. Условия циклического ожидания.\nПравила правильного программирования требуют: если ресурс, который необходим для\nвыполнения того или иного действия, занят другим процессом, выполнение действия\nнеобходимо отложить, а занятые ресурсы - освободить. То есть для нестатичного класса – если\nон захватывает ресурсы, обязательно должен быть dispose.\nПри столкновении с взаимоблокировкой или тупиком, существуют 4 основные стратегии:\n1. Обнаружение и восстановление (нашли, восстановили работу);\n2. В ОС вторая стратегия – структурное опровержение (пр. виртуализация ресурсов) одного из 4\nусловий возникновения тупиковой ситуации;\n3. Пренебрежение проблемы в целом;\n4. Аккуратное распределение и планирование ресурсов. "
        answer[6] =
            "Основная цель планирования вычислительного процесса - распределение времени процессора\nмежду выполняемыми процессами. Все виды планирования, используемые в современных ОС,\nделятся на:\n1. Долгосрочное планирование принимает решение о добавлении процесса в пул\nвыполняемых. Чаще всего долгосрочный планировщик не влияет на пользовательские процессы, только если занято не менее 80% оперативной памяти.\n2. Среднесрочное планирование принимает решение о добавлении процесса к числу\nпроцессов, полностью или частично размещенных в основной памяти. Этот планировщик\nработает для всех процессов, включая пользовательские. Его работу можно заметить, если\nзапускать одновременно много процессов.\n3. Краткосрочное планирование принимает решение о том, поток какого процесса будет\nвыполняться.\n4. Планирование ввода/вывода принимает решение о том, операция какого процесса или\nпотока будет выполняться свободным устройством ввода/вывода. Заключается в\nвыстраивании ОС порядка выполнения критических секций или критический областей.\nВ мультипрограммной системе поток может меняться, если:\n1. Поток завершился и покинул систему;\n2. Произошла ошибка;\n3. Поток перешел в состояние ожидания;\n4. Исчерпан квант времени.\nЕсли происходит ситуация завершения потока с ошибкой или без, то ОС реагирует на такую\nситуацию одинаково - полностью перестаивая очередь от момента завершения активного потока.\nВ момент ожидания ввода/вывода ОС создает новый поток, который становится в очереди на\nвыполнение очень близко к выполняющемуся, пропустив только привилегированные потоки."
        answer[7] =
            "Память – важнейший ресурс вычислительной системы, требующий аккуратного\nраспределения для выполнения следующих пунктов: 1. Модули создавались и компилировались независимо друг от друга;\n2. Разные степени защиты модулей - с помощью API ОС можно в рамках своего процесса создать закрытую область памяти, доступ в которую будет иметь только ваш процесс;\n3. Возможно применение механизмов для совместного использования одних и тех же модулей.\nКогда мы пишем использование общих модулей, ОС не создает отдельно в памяти для каждого\nпроцесса их экземпляр. Существует область в памяти и процесс, который за это отвечает. При\nобращении к таким модулям запрос приходит синхронно. А область, к которой мы обращаемся,\nработает в асинхронном режиме, создавая отдельные потоки или процессы для решения нашей\nзадачи.\nОсновной закон по памяти гласит: программы, расширяясь, стремятся заполнить весь\nдоступный объем. Это выводит следующие устойчивые соотношения:\n1. Чем меньше время доступа, тем дороже бит. Выполняется в тот момент, когда несколько\nпроцессов попеременно обращаются к одному и тому же куску оперативной памяти. При этом\n        чем быстрее происходит обращение и выгрузка, тем больше процессов могут работать с\nодним и тем же куском.\n2. Чем выше ёмкость, тем ниже стоимость бита. Не надо выгружать в файл подкачки и\nстановится не важно сколько оперативной памяти занято.\n3. Чем выше ёмкость, тем больше время доступа. Если оперативной памяти становится очень\nмного, ОС делит процесс на большое количество участков, и выгрузка, и возвращение\nпроцесса на его место занимает продолжительное время.\nВиртуализация памяти (прослойка между оперативной памяти и жестким диском) возможна с\nпомощью 2-х методов:\n1. Swaping (выгружает весь процесс на ЖД). По сравнению с виртуальной памятью 2 основных\nнедостатка:\na. Избыточность перемещаемых данных;\nb. Невозможность загрузить процесс, виртуальное пространство которого превышает\nсвободную память.\nДостоинство Swaping’a заключается в скорости преобразования виртуальных адресов в\nреальные.\n2. Виртуальная память (выгружает процесс частями на ЖД)."
        answer[8] =
            "Методы распределения памяти относительно процессов: • С использованием внешней памяти:\n• Страничное перемещение;\n• Сегментное перемещение;\n• Странично–сегментное перемещение. • Без использования внешней памяти (Нет места механизму виртуализации. ОС для каждого символьного имени настраивает реальные физические адреса):\n• Фиксированные разделы - память выделяется процессом одними и теми же кусками, вне зависимости от размера сохраняемых данных;\n• Динамические разделы – разделы, начальный и конечный адрес которых ОС определяет в момент инициализации переменных;\n• Перемещаемые разделы –изначально делятся в динамические, а после этого\nразделяются на фиксированные. "
        answer[9] =
            "Методы повышения эффективности функционирования страничной виртуальной памяти:\n1. Более сложная структуризация виртуального адресного пространства (например, двухуровневая\n-типичная для 32-битовой адресации).\n2. Использование специального высокоскоростного кэша для хранения части записей таблицы\nстраниц, который обычно называют буфером быстрого преобразования адреса, или буфером\nпоиска трансляции (translation lookaside buffer – TLB);\n3. Выбор оптимального размера страницы виртуальной памяти;\n4. Эффективное управление страничным обменом."
        answer[10] =
            "Назначение ОС можно разделить на 4 основные составляющие: 1. Организация удобного интерфейса меду приложениями и пользователями с одной стороны и\nаппаратурой компьютера с другой. В этот пункт входят следующие сервисы:\na) Разработка программы;\nb) Исполнение программы;\nc) Доступ к устройствам ввода\\вывода;\nd) Контролируемый доступ к файлам;\ne) Системный доступ;\nf) Обнаружение ошибок и их обработка;\ng) Учет использования ресурсов.\n2. Организация эффективного использования ресурсов компьютера:\na) Планирование ресурса;\nb) Удовлетворение запроса на ресурс – решается механизмом блокировок;\nc) Отслеживание состояния и учет использования ресурса;\nd) Разрешение конфликтов между процессами, претендующими на один и тот же ресурс.\n3. Облегчение процессов эксплуатации аппаратных и программных средств:\na) Диагностика;\nb) Средство восстановления последней работоспособной конфигурации;\nc) Средство восстановления поврежденных файлов.\n4. Возможность развития:\na) Обновление аппаратного перечня;\nb) Новые сервисы и исправления."
        answer[11] =
            "1. Средства аппаратной поддержки ОС. Система прерываний, средства поддержки\nпривилегированного режима, средства поддержки виртуальной памяти, системный таймер,\nинформация о состоянии процесса в момент его приостановки, средства защиты памяти и др.\n2. Машинно-зависимые модули ОС. Этот слой образует модули, в которых отражается\nспецифика аппаратной платформы компьютера. Назначение этого слоя – «экранирование»\nвышележащих слоев ОС от особенностей аппаратуры.\n3. Базовые механизмы ядра. Этот слой модулей выполняет наиболее примитивные операции\nядра: программное переключение контекстов процессов, диспетчерскую прерываний,\nперемещение страниц между основной памятью и диском и т.п. Модули этого слоя\nобрабатывают решения, принятые модулями вышележащих уровней.\n4. Менеджеры ресурсов. Модули этого слоя выполняют стратегические задачи по управлению\nресурсами вычислительной системы. Это менеджеры процессов ввода-вывода, оперативной\nпамяти и файловой системы. Каждый менеджер ведет учет свободных и используемых\n        ресурсов и планирует их распределение в соответствии запросами приложений.\n5. Интерфейс системных вызовов. Это верхний слой ядра ОС, взаимодействующий с\nприложениями и системными утилитами, он образует прикладной программный интерфейс\nОС. Функции API, обслуживающие системные вызовы, предоставляют доступ к ресурсам\nсистемы в удобной компактной форме, без указания деталей их физического расположения."
        answer[12] =
            "1. по назначению:\na. универсальные – подходят для решения практически любых задач;\nb. специализированные – имеют ограниченный круг задач.\n2. по особенностям алгоритмов управления ресурсами:\na. поддержка многозадачности - современные ОС являются многозадачными;\nb. поддержка многопользовательского режима - современные ОС являются\nмногопользовательскими;\nc. многопроцессорная обработка;\nd. виды многопрограммной работы: не вытесняющие многозадачность и вытесняющие\nмногозадачность. Современные ОС широкого использования являются вытесняющими ОС.\n3. по способу загрузки в оперативную память:\na. загружаемые ОС - все классические ОС являются загружаемыми;\nb. постоянно находящиеся ОС.\n4. по области использования и форме эксплуатации:\na. системы пакетной обработки - смысл заключается в необходимости обсчета\nопределенных данных, и пока он не завершается, ОС не занимается другими задачами;\nb. разделение времени - современные классические ОС являются системами разделения\n        времени;\nc. реального времени.\n5. по аппаратной платформе:\na. ОС для смарт-карт;\nb. встроенные ОС (BIOS);\nc. для ПК (планшетов, телефонов и тд);\nd. для мини-ЭВМ;\ne. для мэйнфреймов;\nf. серверные ОС;\ng. кластерные ОС. "
        answer[13] =
            "Виртуализация ́— предоставление набора вычислительных ресурсов или их логического\nобъединения, обеспечивающее при этом логическую изоляцию друг от друга вычислительных\nпроцессов, выполняемых на одном физическом ресурсе.\nВиртуализация позволяет отделить ПО от низлежащей аппаратной инфраструктуры. Разрывает связь между определенным набором команд и конкретным компьютером. Обеспечивает высокий\nуровень работоспособности и безопасности благодаря нескольким ключевым возможностям.\nЛокализация неисправностей. Большинство отказов приложений происходят из-за ошибок ПО.\nВиртуализация обеспечивает логическое разделение виртуальных разделов, поэтому программный\nсбой в одном разделе никак не влияет на работу приложения в другом разделе. Логическое\nразделение также позволяет защищаться от внешних атак, что повышает безопасность\nконсолидированных сред.\nГибкая обработка отказов. Виртуальные разделы можно настроить так, чтобы обеспечить\nавтоматическую обработку отказов для одного или нескольких приложений. Благодаря средствам\nобеспечения высокой степени работоспособности, требуемый уровень услуг часто можно\nобеспечить, предусмотрев аварийный раздел на той же платформе, где работает основное\nприложение. Если требуется еще более высокий уровень работоспособности, аварийный раздел\nможно разместить на отдельной платформе.\nРазные уровни безопасности. Для каждой виртуальной машины можно установить разные\nнастройки безопасности.\nГибкость управления ресурсами, которую обеспечивают МВМ (малая вычислительная машина),\nможет сделать системы более стойкими к нападениям.\nВиртуализация предоставляет также преимущества для сред разработки и тестирования ПО.\nРазличные этапы цикла создания ПО, включая получение рабочей версии, можно выполнять в\nразных виртуальных разделах одной и той же платформы. Это поможет повысить степень полезного использования аппаратного обеспечения и упростить управление жизненным циклом.\nВиртуализация позволяет обойти несовместимость разных интерфейсов. Виртуализация системы или компонента подсистема управления процессами и потоками на конкретном уровне\nабстракции отображает его интерфейс и видимые ресурсы на интерфейс и ресурсы реальнойсистемы. Следовательно, реальная система выступает в роли другой, виртуальной системы или\nдаже нескольких виртуальных систем."
        answer[14] =
            "Мультипрограммирование – способ организации вычислительного процесса, при котором на одном процессоре попеременно выполняются несколько программ. Чтобы поддержать мультипрограммирование, ОС разделяет для себя процессы на внутренние единицы, которые и обрабатываются на процессоре. На большинстве ОС крупной единицей считается процесс или задача, менее крупной – поток или нить. Наиболее характерными показателями эффективности вычислительных систем являются: \n1. Пропускная способность – количество задач, которые может решать ОС за одну единицу времени. Стоимость в каждой задаче для пропускной способности усредняется; \n2. Удобство работы пользователей – возможность одновременной работы с несколькими приложениями на одной машине; \n3. Реактивность системы – способность выдерживать заранее заданные интервалы времени между запуском программы и получением конечного результата. В зависимости от выбора одного из этих показателей эффективности, ОС делятся на: \n• Системы пакетной обработки – пренебрегают всеми характеристиками, кроме реактивности системы. А количество времени, которое ОС потратит на решение задачи должно быть строго выдержано. \n• Системы разделения времени –возможность интерактивной работы сразу с несколькими приложениями, для этого приложения должно регулярно получать возможность общения с пользователем. Это решается за счет того, что ОС принудительно останавливает приложения. Все привычные нам ОС - разделения времени. Главным показателем является удобство работы пользователя и пропускная способность, реактивность системы отходит на второй план. В ОС разделения времени приоритет отдается тем процессам, которые в настоящее время «ведут общение с пользователем». \n• Системы реального времени – предназначены для управления техническими объектами, технологическими процессами и системами массового обслуживания. Для данной ОС главной характеристикой является реактивность, потому что время выполнения задачи строго регламентировано и не должно увеличиваться. \nСемафор - целая переменная, принимающая неотрицательные значения. Доступ любого процесса к ней, за исключением момента ее инициализации, может осуществляться только через две атомарные операции: \nP (proberen – проверять) и V (от verhogen – увеличивать). Классическое определение этих операций выглядит следующим образом: \nP(S): пока S == 0 процесс блокируется; \nS = S - 1;\n V(S): S = S + 1;\nПри выполнении операции P над семафором S, проверяется его значение. \nЕсли оно > 0, то из S вычитается 1. Если оно < или = 0, процесс блокируется, пока S не станет > 0, после чего из S вычитается 1. \nПри выполнении операции V над семафором S к его значению просто прибавляется \n1. Мониторы - тип данных, который может быть с успехом внедрен в языки ООП. Обладает собственными переменными, определяющими его состояние. Их значения извне монитора могут быть изменены только с помощью вызова функций-методов, принадлежащих ему. Эти функции-методы могут использовать данные, находящиеся внутри монитора, и свои параметры. Важная особенность мониторов - в любой момент времени только один процесс может быть активен, т. е. находиться в состоянии \"готовность\" или \"исполнение\", внутри данного монитора. Поскольку мониторы представляют собой особые конструкции языка программирования, компилятор может отличить вызов функции, принадлежащей монитору, от вызовов других функций и обработать его специальным образом, добавив к нему пролог и эпилог, реализующий взаимоисключение."
        answer[15] =
            "Создание процессов и потоков приводит 5 основных событий:\n1. инициализация ОС; 2. выполнение запроса работающего процесса на создание нового;\n3. запрос пользователя на создание процесса;\n4. инициирование пакетного задания;\n5. создание процесса для выполнения какой-либо службы.\nВ момент старта процесса весь исполняемый код загружается в оперативную память для последующего исполнения. Если есть блокирующий код, это будет отдельный поток. При создании\nпроцесса всегда создается основной поток, выполняющий весь код, если не предусмотрена\nмультипоточность. Только блокирующий ввод/вывод создается в виде отдельных потоков. Он создается отдельными потоками, чтобы основной не переходил на уровень kernel, так как чаще\nвсего в этом нет необходимости.\nИнформация по состоянию и управлению процессом включает следующие основные данные:\n1. идентификатор процесса (GUID, содержит 36 символов: буквы в нижнем регистре, цифры, и\nтире);\n2. индекс процесса (число);\n3. состояние процесса;\n4. данные о приоритете (число);\n5. информация о событиях – массив или список всех событий, которые совершены за один\nсеанс работы. Тот список, который ОС показывает при просмотре событий является\nвиртуальной таблицей, которая содержит описание события. В реальной таблице описание\nне хранится;\n6. указатели на оперативную память и жесткий диск – содержат следующую информацию (в\nотдельной таблице):\na. индекс процесса;\nb. начальные адрес в оперативной памяти;\nc. конечный адрес в ОП;\nd. начальный адрес на жестком диске;\ne. конечный адрес на ЖД.\n7. указатели на ресурсы – это так же отдельная таблица, в которой хранится информация по\nресурсам, которые заблокировал процесс в настоящее время;\n8. указатели на другие процессы – в таблице, которая хранит на другие процессы содержится\nинформация о родителе процесса. В момент завершения процесса все его живые потомки\nпереходят на уровень самого процесса;\n9. флаги, сигналы и сообщения, имеющие отношение к обмену информации между\nнезависимыми процессами;\n10. данные о привилегиях – в отличии от приоритета данные о привилегиях содержатся в\nотдельной таблице и могут иметь разное значение на различные ресурсы. В таблице\nпривилегий содержится информация как о запретах, так и о разрешениях на те или иные\nресурсы;\n11. сведения по истории использования ресурсов;\n12. информация, связанная с планированием.\nВ таблице процессов хранятся только активные процессы. Максимально возможное время\nхранение завершенного процесса в этой таблице – 30 секунд. (Чистит процессы фоновое задание)\nУ процесса могут быть следующие состояния:\n1. выполняющийся;\n2. готовый к выполнению;\n3. ожидающий какого-либо события;\n4. приостановленный.\nСостояние процесса, в котором он ожидает какого-либо события, чаще всего является\nсостояниями ожидания ввода/вывода. Состояние приостановленного – ожидание очереди на выполнение. В ОС существует 2 способа выполнения потоков:\n1. на уровне пользователя (ULT – user level threads);\n2. на уровне ядра (KLT – kernel level threads). В ОС разделения времени потоки работают на уровне пользователя и только в случае строгой\nнеобходимости переходят на уровень ядра. Преимущества при работе потоков на уровне пользователя:\n1. производительность;\n2. различные алгоритмы планирования;\n3. применимость для любой ОС.\nНедостатки:\n1. количество потоков;\n2. отсутствие возможности принудительно забрать ЦП;\n3. не всегда можно пользоваться преимуществами многопроцессорной системы.\nСистемный вызов позволяет приложению обратиться к ОС с просьбой выполнить действие,\nоформленное как процедура кодового сегмента ОС. В этом плане для прикладного программиста ОС представляется некоторой библиотекой, имеющей набор различных функций, с помощью которых\nможно упростить прикладную программу или выполнить действия, запрещенные в\nпользовательском режиме.\nРеализация системных вызовов должна удовлетворять следующим требованиям:\n• обеспечивать переключение в привилегированный режим; • обладать высокой скоростью вызова процедур ОС;\n• обеспечивать по возможности единообразное обращение к системным вызовам для всех\n    аппаратных платформ, на которых работает ОС;\n• допускать простое расширение системных вызовов; • обеспечивать контроль со стороны ОС за корректным использованием системных вызовов."
        answer[16] =
            "В ОС существуют 3 способа взаимодействия процессов и потоков:\n1. Конкуренция - процессы не осведомлены друг о друге. Возможно появление трех основных\nпроблем:\na. взаимоблокировки (2 процесса обращаются к 1 неразделяемому ресурсу);\nb. взаимоисключение (2 процесса, обратившись к ресурсу и не получив доступа, должны быть оба остановлены одновременно или остановлен только один);\nc. голодание (отсутствие ресурса, необходимого для выполнения задачи).\n2. Процессы косвенно осведомлены друг о друге. Проблемы:\na. Взаимоисключения;\nb. Взаимоблокировки;\nc. Голодание;\nd. Синхронизация.\n3. Процессы непосредственно осведомлены друг о друге\na. Взаимоблокировки;\nb. Голодание.\nЕсли процессы требуют доступ к одному неразделяемому ресурсу, такой ресурс называется\nкритическим ресурсом, а использующая его часть программы - критическим разделом или\nкритической секцией."
        answer[17] =
            "1. Учет свободной и занятой памяти;\n2. Первоначальное и динамическое выделение памяти процессам и освобождение памяти по завершению;\n3. Настройка адресов программы на конкретную область физической памяти; 4. Полное или частичное вытеснение кодов и данных процессов на жесткий диск;\n5. Защита памяти;\n6. Дефрагментация памяти.\nМеханизм виртуальных адресов применяется для отслеживания свободной и занятой памяти. Он позволяет для одного символьного имени создать один и более виртуальный адрес, который может\nраспределяться на множество физических.\nОС контролирует физические адреса, для динамического выделения создаются новые виртуальные\nадреса.\nИспользование ссылок на переменные и оперативную память требуют наличия обходного пути.\nПри полном или частичном вытеснении изначальная ОС давно не используемые виртуальные\nадреса.\nС целью защиты памяти соответствие виртуального и физических адресов получить от ОС невозможно.\nДефрагментация – это фоновое задание, которое запускается раз в 20-30 секунд."
        answer[18] =
            "Страничная виртуальная память организует перемещение данных между основной памятью и\nдиском страницами, а именно частями виртуального адресного пространства фиксированного и\nсравнительного небольшого размера. Размер страницы определяется в байтах по степени двойки.\nЗапись таблицы страниц содержит следующую информацию:\n1. Номер физической страницы;\n2. Признак присутствия;\n3. Признак обращения;\n4. Признак модификации;\n5. Другие управляющие биты.\nСтратегии управления страничным обменом между ЖД и оперативной памятью:\n1. Стратегия выборки («когда?») – предварительная выборка, которая подготавливает данные\nподпроцесса до того, как процесс запросил оперативную память. (Используется в windows)\n2. Стратегия размещения («где?») – находит первый подходящий раздел, либо первые\nстраницы, которые схожи по запрашиваемой памяти. (Используется в windows)\n3. Стратегия замещения (FIFO);\n4. Управление резидентным множеством – работает по принципу фиксированного размера,\nпеременного размера, локальной и глобальной зоной видимости. В случае с резидентным\nмножеством, мы используем те страницы, которые требуют процесс самостоятельно.\n5. Стратегия очистки - выполняется по требованию или предварительно. (Используется в\n        windows)\n6. Управление загрузкой (рабочее множество – 50%) – находит 50% и затем остальные 50%\nочищает."
        answer[19] =
            "Сегмент - множество полностью независимых адресных пространств. Каждый сегмент содержит\nлинейную последовательность адресов от 0 до некоторого максимума. Различные сегменты могут быть различной длины, Изменяющейся во время выполнения. Поскольку каждый сегмент составляет\nотдельное адресное пространство, разные сегменты могут расти и сокращаться независимо друг от\nдруга. Является логическим объектом.\nПреимущества сегментированной памяти: • простота компоновки отдельно скомпилированных процедур (обращение к начальной точке\nпроцедуры осуществляется адресом вида (n,0), где n – номер сегмента); • легкость обеспечения дифференцируемого доступа к различным частям программы\n(например, запретить обращаться для записи в сегмент программы); • простота организации совместного использования фрагментов программ различными\nпроцессами, например, библиотеки совместного доступа могут быть оформлены в виде\nотдельного сегмента, который может быть включен в виртуальное адресное пространство\nнескольких процессов.\nТаблица сегментов процесса содержит: • базовый физический адрес начала сегмента в оперативной памяти; • размер сегмента; • правила доступа к сегменту; • признаки модификации, присутствия и обращения к данному сегменту, а также некоторая\nдругая информация.\nНедостатки:• использование операции сложения вместо конкатенации замедляет процедуру\nпреобразования виртуального адреса в физический; • большая избыточность перемещения данных между диском и оперативной памятью,\nпоскольку перемещаются целиком большие сегменты. Во многих случаях было бы достаточно загружать и выгружать одну или несколько страниц; • внешняя фрагментация, возникающая из-за произвольных размеров сегментов."
        answer[20] =
            "Функции подсистемы ввода/вывода:\n1. Организация параллельной работы устройств ввода/вывода и процессора;\n2. Согласование скоростей обмена и кэширования данных;\n3. Разделение устройств и данных между процессами;\n4. Обеспечение удобного логического интерфейса между устройствами и остальной частью\nсистемы;\n5. Поддержка широкого спектра драйверов;\n6. Динамическая загрузка и выгрузка драйверов;\n7. Поддержка различных файловых систем;\n8. Поддержка синхронных и ассинхронных операций ввода/вывода.\nСпособы выполнения операций ввода\\вывода:\n1. Программируемый ввод/вывод - для ЦП передается команда, он её выполняет>, посылая\nкоманды контроллеру ввода/вывода. Это устройство выполняет необходимые действия,\nустанавливает соответствующие биты в регистрах, в том числе состояние, но не может\nпосылать никаких команд, в том числе прерывания, это выполняет ЦП.\n2. Ввод/вывод, управляемый прерываниями. В этом случае процессор посылает необходимые\nкоманды контроллеру ввода/вывода, продолжая выполнять текущий процесс, и если нет\nнеобходимости в ожидании операции ввода/вывода, то процесс не приостанавливается до\nполучения сигнала прерывания.\n3. Прямой доступ к памяти (DMA – Direct Memory Access). В случае использования прямого\nдоступа к памяти специальный модуль управляет обменом между основной памятью и\nконтроллером ввода/вывода. В этом случае процессор посылает запрос на передачу блока\n        данных модулю, а прерывание происходит по необходимости только после передачи всего\nблока."
        answer[21] =
            "При обмене данных всегда возникает задача согласования скоростей работы устройств.\nРешением этой задачи является буферизация, то есть все данные сначала помещаются в\nоперативную память.\nДля согласования скоростей используется буферизация на ЖД с помощью спул-файлов, либо\nиспользуется буферная память самих устройств. В этом случае ОС сразу передает данные из оперативной памяти в буфер внешнего устройства, очищая при этом оперативную память.\nВ случае, если используется ОЗУ + файл подкачки - это либо одинарная, либо двойная\nбуферизация. Второй случай предполагает циклическую буферизацию."
        answer[22] =
            "Задача разделения данных и устройств ввода/вывода между процессами заключается в решении двух подзадач:\n1.Подзадача монопольного доступа;\n2.Подзадача разделения между несколькими процессами - решается с помощью блокировки части ресурса от изменений другими процессами.\nОдно и то же устройство в разные периоды времени может работать в разделяемом и в\nмонопольном режимах.Для некоторых характерен только один из них.\nВ случае совместного использования ОС должна оптимизировать последовательность операций\nввода\\вывода для различных процессов для повышения общей производительности.\nПри разделении устройства между процессами может возникнуть необходимость в разграничении данных процессов друг от друга.Обычно она появляется при совместном использовании последовательных устройств, которые, в отличие от устройств прямого доступа, не адресуются. Для\nних организуется очередь заданий на вывод, каждое задание -порция данных, которую нельзя\nразрывать."
        answer[23] =
            "Разнообразие устройств ввода-вывода делает актуальной функцию ОС по созданию экранирующего\nлогического интерфейса между периферийными устройствами и приложениями.\nДля этого используется файловая модель периферийных устройств, когда любое устройство\nвыглядит для прикладного программиста последовательным набором байт, с которым можно\nработать с помощью унифицированных системных вызовов, задавая имя файла-устройства и\nсмещение от начала последовательности байт.\nМодель файла-устройства простая и унифицированная для устройств любого типа, но во многих\nслучаях для программирования операций ввода-вывода некоторого устройства она является\nслишком бедной. Поэтому она часто используется в качестве базиса, над которым подсистема\nввода-вывода строит более содержательную модель устройства конкретного типа.\nДинамическая загрузка и выгрузка драйверов\nТак как набор потенциально поддерживаемых данных ОС периферийных устройств всегда шире\nнабора устройств, которыми ОС должна управлять при установке на конкретной машине, ценным\nсвойством ОС является возможность динамически загружать в оперативную память требуемый\n        драйвер (без остановки ОС) и выгружать его, если надобность в драйвере отпала. Такое свойство\nОС может существенно сэкономить системную область памяти.\nАльтернативой динамической загрузке драйверов при изменении текущей конфигурации внешних\nустройств компьютера является повторная компиляция кода ядра с требуемым набором драйверов,\nчто создает между всеми компонентами ядра статические связи вместо динамических. При статистических вызовах между ядром и драйверами структура ОС упрощается, но этот подход\nтребует наличия исходных кодов модулей ОС, доступность которых скорее является исключением. В этом варианте работающую версию ОС надо остановить и заменить новой, что не всегда допустимо в\nнекоторых применениях.\nПоэтому поддержка динамической загрузки драйверов является практически обязательным\n        требованием для современных универсальных ОС."
        answer[24] =
            "Для разработки драйверов необходимо открытое API. В первую очередь – модуль ядра, и\nинтерфейс драйвер-ядро должен быть стандартизирован в любом случае. Для этого во всех ОС\nсуществует несколько различных интерфейсов, чаще всего используются два: DKI и DDI,\nпредоставляя интерфейс для блочных и символьных устройств. У драйверов существуют следующие функции:\n1. Обработка запросов записи и чтения от процессов;\n2. Проверка входных параметров и обработка ошибок;\n3. Инициализация устройства - помимо физического запуска устройства, драйвер должен\nотдать в ядро ОС определенную структуру, в противном случае устройство не считается\nзапущенным;\n4. Управление энергопотреблением;\n5. Регистрация событий;\n6. Выдача команд (для устройства);\n7. Проверка правильности завершения – выполняется с помощью определенной команды в ядро\nОС;\n8. Передача запрошенных данных;\n9. Обработка нового запроса при незавершенном предыдущем."
        answer[25] =
            "Функции подсистемы ввода/вывода: \n1. Организация параллельной работы устройств ввода/вывода и процессора; \n2. Согласование скоростей обмена и кэширования данных; \n3. Разделение устройств и данных между процессами;\n 4. Обеспечение удобного логического интерфейса между устройствами и остальной частью системы; \n5. Поддержка широкого спектра драйверов;\n6. Динамическая загрузка и выгрузка драйверов; \n7. Поддержка различных файловых систем; \n8. Поддержка синхронных и ассинхронных операций ввода/вывода. \nОперация ввода-вывода может выполняться по отношению к программному модулю, запросившему операцию, в синхронном или асинхронном режимах. Синхронный означает, что программный модуль приостанавливает свою работу, пока операция ввода-вывода не будет завершена. В асинхронном -программный модуль продолжает выполняться в мультипрограммном режиме одновременно с операцией ввода-вывода. \nОтличие в том, что операция ввода-вывода может быть инициирована не только пользовательским процессом – в этом случае операция выполняется в рамках системного вызова, – но и кодом ядра, например, кодом подсистемы виртуальной памяти для считывания отсутствующей страницы. \nСистемы вызовы ввода-вывода чаще оформляются как синхронные процедуры в связи с тем, что такие операции длятся долго и пользовательскому процессу или потоку все равно придется ждать получения результатов потоков операции, для того чтобы продолжить свою работу. \nВнутренние вызовы операций ввода-вывода из модулей ядра обычно выполняются в виде асинхронных процедур, так как кодам ядра нужна свобода в выборе дальнейшего поведения после запроса ввода-вывода."
        answer[26] =
            "ПО подсистемы ввода-вывода делится на горизонтальные и вертикальные слои. В каждой\nвертикальной подсистеме – несколько слоев модулей. Нижний слой образует аппаратные драйверы,\nуправляющие аппаратурой внешних устройств, осуществляя обмен байтами и блоками байтов. Этот\nслой ПО не имеет дела с вопросами логической организации данных, например, с файлами или\nсложными графическими объектами. Функции вышележащих слоев в значительной степени зависят\nот типа вертикальной подсистемы. "
        answer[27] =
            "«Драйвер» – программный модуль, который: • входит в состав ядра ОС, работая в привилегированном режиме;\n• непосредственно управляет внешним устройством, взаимодействуя с его контроллером с\nпомощью команд ввода-вывода компьютера; • обрабатывает прерывания от контроллера устройства;\n• предоставляет прикладному программисту удобный логический интерфейс работы с\n    устройством, экранируя от него низкоуровневые детали управления устройством и\nорганизации его данных; • взаимодействует с другими модулями ядра ОС с помощью строго оговоренного интерфейса,\nописывающего формат передаваемых данных, структуру буферов, способы включения\nдрайвера в состав ОС, способы вызова драйвера, набор общих процедур подсистемы ввода вывода, которыми драйвер может пользоваться и т.п.\nТрадиционные драйверы (аппаратные, низкоуровневые или драйверы устройств) освобождаются\nот высокоуровневых функций и занимаются только низкоуровневыми операциями. При таком\nподходе повышается гибкость и расширяемость функции по управлению устройством.\nВысокоуровневые драйверы оформляются по тем же правилам и придерживаются тех же\nвнутренних интерфейсов. Они не вызываются по прерываниям, так как взаимодействуют с\nустройством через посредничество аппаратных драйверов.\nАппаратные драйверы после запуска операции ввода-вывода должны своевременно реагировать\n        на завершение контроллером заданного действия путем взаимодействия с системой прерывания.\nДрайверы более высоких уровней вызываются не по прерываниям, а по инициативе аппаратных\nдрайверов или драйверов вышележащего уровня. "
        answer[28] =
            "Существуют следующие требования для хранения данных на устройствах:\n1. Устройства должны позволят хранить данные в больших объемах;\n2. Информация должна длительно и надежно сохраняться после прекращения работы процесса;\n3. Несколько процессов должны иметь возможность получения одновременного доступа к\nинформации.\nПри рассмотрении отдельных файлов и их совокупностей используются следующие понятия:\n1. Поле – основной элемент данных; 2. Запись – набор связанных между собой полей, которые могут быть обработаны как единое\nцелое некоторой прикладной программы. Запись необходимо рассматривать как экземпляр\n        класса;\n3. Файл – совокупность однородных записей. Центральным объектом файловой системы\nявляется файл. На текущий момент обязательно использование StreamWrite и StreamRead\nдля записи и чтения файлов. При работе с большими объемами данных необходимо\nпреобразовывать всё в байты, а после этого при необходимости разбивать на массив\nисходную последовательность и работать с этим массивом в несколько потоков, используя\nделегаты для взаимодействия между этими потоками;\n4. База данных – набор связанных между собой данных, представленных совокупностью файлов\nодного или нескольких типов. При записи большого количества данных (от 1000 INSERT’ов\nодновременно) или при записи в несколько таблиц необходимо пользоваться транзакциями,\nчтобы в случае проблемы все остаточные данные удалялись без вашего участия.\nФайловая система – это часть ОС, которая включает в себя:\n1. Совокупность всех файлов на носителе информации;\n2. Наборы структур данных, используемых для управления файлами. (Дескрипторы файлов,\nтаблица распределения свободного и занятого пространства и хранение файлов (каталоги));\n3. Комплекс системных программных средств, реализующих различные операции над файлами\n(Создание, уничтожение, чтение, запись итд).\nЗадачи файловой системы в мультипрограммных многопользовательских ОС:\n1. Соответствие требованиям управления данными и требованиям со стороны пользователей;\n2. Гарантирование корректности данных. Проверка четности и контрольная сумма;\n3. Оптимизация производительности, как с точки зрения системы, так и с точки зрения\nпользователя. Со стороны пользователя – время отклика, со стороны системы – пропускная\nспособность;\n4. Поддержка ввода/вывода для различных типов устройств хранения информации;\n5. Минимизация или полное исключение потерь и повреждений данных;\n6. Защита от несанкционированного доступа. В большинстве файлов систем устроена с\nпомощью ролей доступа;\n7. Обеспечение поддержки совместного использования;\n8. Обеспечение стандартизированного набора подпрограмм интерфейса ввода/вывода. В\n        данном пункте понимается, как единообразие открытия и чтения, так и единообразия записи\nи изменения.\nМинимальным набором требований системы со стороны пользователя является:\n1. Создание, удаление, чтение и изменение файла;\n2. Контролируемый доступ к файлам;\n3. Управление доступом к своим файлам;\n4. Реструктурирование файлов в соответствии с решаемой задачей;\n5. Перемещение данных между файлами;\n6. Резервирование и восстановление файлов в случае повреждения;\n7. Доступ к файлам по символьным именам. "
        answer[29] =
            "На нижнем уровне драйверы устройств непосредственно связаны с периферийными устройствами или их котроллерами либо каналами. Драйвер устройства отвечает за начальные операции ввода вывода устройства и за обработку завершения запроса ввода-вывода.\nСледующий уровень называется базовой файловой системой, или уровнем физического ввода вывода. Это первичный интерфейс с окружением (периферией) компьютерной системы. Он\nоперирует блоками данных, которыми обменивается с дисками, магнитной лентой и другими\nустройствами.\nДиспетчер базового ввода-вывода отвечает за начало и завершение файлового ввода-вывода.\nДиспетчер осуществляет выбор устройства, на котором будет выполняться операция файлового\nввода-вывода, планирование обращения к устройству (дискам, лентам), назначение буферов ввода вывода и распределение внешней памяти.\nЛогический ввод-вывод предоставляет приложениям и пользователям доступ к записям. Он\n        обеспечивает возможности общего назначения по вводу-выводу записей и поддерживает\n        информацию о файлах, обеспечивает стандартный интерфейс между приложениями и файловыми\nсистемами и устройствами, содержащими данные. Различные метод"
        answer[30] =
            "Использование собственных расширений файлов усложняет работу файловой системы в части\nиндексации и поиска, так как файловая система пытается выполнить 2 действия: • Применить известные ей форматы для индексирования; • Проиндексировать как текст.\nУ файла существуют следующие атрибуты:\n1. Тип файла (обычный, каталог, специальный);\n2. Владелец файла (появляется в момент использования);\n3. Создатель файла;\n4. Дата создания;\n5. Дата изменения;\n6. Пароль;\n7. Текущий размер файла;\n8. Максимальный размер;\n9. Флаг “только чтение” – на 60% может повысить защищенность важных файлов;\n10. Флаг “скрытый”;\n11. Флаг “системный” - файл запрещено переименовывать и менять расширение, но этот\nпроцесс не всегда контролируется файловой системой;\n12. Флаг “архивный” – требуется или не требуется архивация;\n13. Флаг “ASCII /двоичный”. Двоичные данные – это тип BASE64;\n14. Флаг произвольного доступа – либо только последовательный, либо только произвольный\nдоступ;\n15. Флаг “временный” – после окончания процесса данный файл должен быть уничтожен;\n16. Позиция ключа;\n17. Длина ключа;\n18. Средняя длина имени файла – 8 байт.\nИзвестно пять фундаментальных способов организации файлов: • смешанный файл; • последовательный файл; • индексно-последовательный файл; • индексируемый файл; • файл прямого доступа."
        answer[31] =
            "Файловый каталог - связующее звено между системой управления файлами и набором. Он содержит информацию о файлах, включая атрибуты, местоположение, принадлежность. Каталоговые системы имеют иерархическую структуру. Граф, описывающий иерархию каталогов, может быть деревом или сетью. Каталоги образуют дерево, если файлу разрешено входить только в один каталог, и сеть, если файл может входить в несколько каталогов. \nНапример, в Ms-Dos и Windows каталоги образуют древовидную структуру, а в UNIX – сетевую. \nОдноуровневые каталоговые системы. \nВ этой системе все файлы содержатся в одном каталоге. Однокаталоговая система, содержащая четыре файла, файлов А - два, но разных владельцев. \nПреимущества системы: \n1. Простота; \n2. Возможность быстро найти файл, не надо лазить по каталогам. \nНедостатки системы: \n1. Различные пользователи могут создать файлы с одинаковыми именами. \nДвухуровневые каталоговые системы.\nДля каждого пользователя создается свой собственный каталог. Пользователь, при входе в систему, попадает в свой каталог и работает только с ним. Это делает проблематичным использование системных файлов. \nПроблема решается созданием системного каталога с общим доступом. Если у одного пользователя много файлов, то у него тоже может возникнуть необходимость в файлах с одинаковыми именами. \nИерархические каталоговые системы. \nКаждый пользователь может создавать столько каталогов, сколько ему нужно. Почти все современные универсальные ОС, организованы таким образом. Специализированным ОС это может быть не нужным."
        answer[32] =
            "Принципы размещения файлов, каталогов и системной информации на реальном устройстве описываются физической организацией файловой системы. \nЖесткие и гибкие магнитные диски - основное устройство для хранения файлов. Жесткие диски состоят из одной или нескольких стеклянных или металлических пластин, каждая из которых покрыта с одной стороны или двух сторон магнитным материалом. \nНа каждой стороне каждой пластины размечены тонкие концентрические кольца – дорожки, на которых хранятся данные. Нумерация дорожек начинается с 0 от внешнего края к центру диска. Когда диск вращается, магнитные головки, имеющиеся над (под) каждой поверхностью диска, считывают или записывают двоичные данные на магнитные дорожки. Головки могут позиционировать над каждой дорожкой, если на одну поверхность диска в устройстве имеется одна головка. Некоторые диски имеют по отдельной головке на каждую дорожку, тогда позиционирование головок не требуется, что повышает быстродействие диска. \nСовокупность дорожек одного радиуса на всех поверхностях пластин пакета называется цилиндром. Каждая дорожка разбивается на фрагменты, называемые секторами или блоками, так что все дорожки имеют равное число секторов, в которые можно максимально записать одно и то же число байт. Сектор имеет фиксированный для данной системы размер, выражающийся степенью двойки (чаще всего 512 байт). \nСектор – наименьшая адресуемая единица обмена данными диска с оперативной памятью. Для того чтобы контроллер мог найти на диске нужный сектор, ему необходимо задать все составляющие адреса сектора: номер цилиндра, номер поверхности и номер сектора. Типичный запрос включает чтение (запись) нескольких секторов, содержащих наряду с требуемыми избыточные данные. \nОперационная система при работе с диском использует единицу дискового пространства, называемую кластером и содержащую несколько секторов в числе, кратном степени двойки. Это связано с тем, что применение более мелкой единицы дискового пространства – сектора – усложняет учет свободного и занятого пространства диска при современных больших емкостях дисков, исчисляющихся десятками и сотнями Гбайт. \nДорожки и секторы создаются в результате выполнения процедуры физического (низкоуровнего) форматирования диска, предшествующей использованию диска. Для определения границ блоков на диск записывается идентификационная информация. Низкоуровневый формат диска не зависит от типа ОС, которая с этим диском будет работать. \nРазметку диска под конкретный тип файловой системы выполняют процедуры высокоуровнего, или логического, форматирования. При высокоуровневом форматировании определяется размер кластера, записываются информация, необходимая для работы файловой системы, и загрузчик ОС – небольшая программа, которая начинает процесс инициализации операционной системы после включения питания. \nПрежде чем форматировать диск под определенную файловую систему, он может быть разбит на разделы. Раздел – это непрерывная часть физического диска, которую операционная система представляет пользователю как логическое устройство (логический диск или логический раздел). На каждом разделе может создаваться только одна файловая система."
        answer[33] =
            "Физическая организация выделяет способ размещения файлов на диске и учет соответствия блоков диска файлам. Основные критерии эффективности физической организации файлов:\n1. скорость доступа к данным;\n2. объем адресной информации файла;\n3. степень фрагментированности дискового пространства;\n4. максимально возможный размер файла.\nНаиболее часто используются следующие схемы размещения файлов:\n1. непрерывное размещение;\n2. сводный список блоков файла;\n3. сводный список индексов блоков файла;\n4. перечень номеров блоков файла в i-узлах.\nПростейший вариант физической организации – непрерывное размещение в наборе соседних кластеров. Достоинство – высокая скорость доступа и минимальный объем адресной информации.\nРазмер файла не ограничивается. Недостаток – фрагментация, возрастающая по мере удаления и записи файлов.\nВторой метод – представление файла в виде связного списка кластеров дисковой памяти. Первое слово каждого кластера используется как указатель на следующий кластер. Адресная информация минимальна. Доступ к файлу может медленный, тк для получения доступа к кластеру n ОС должна прочитать первые n-1 кластеры. Размер кластера уменьшается на несколько байтов, требуемых для хранения.\nОба недостатка предыдущей схемы можно устранить, храня указатели на следующие кластеры в отдельной таблице, загружаемой в память. Так образуется связный список индексов, указывающих на блоки файла."
        answer[34] =
            "FAT – Таблица Размещения Файлов (File Allocation Table), все данные о размещении файлов на диске находятся в этой таблице. \nДля обеспечения доступа приложений к файлам операционная система с файловой системой FAT использует следующие структуры: \n1. загрузочные секторы главного и дополнительных разделов; \n2. загрузочные секторы логических дисков (разделов); \n3. корневой каталог; \n4. область данных; \n5. цилиндр для выполнения диагностических операций чтения-записи. \nЗагрузочный сектор главного раздела (называемый главной загрузочной записью – Master Boot Record – MBR) является первым сектором на жестком диске и состоит из двух элементов: \n1. таблица главного раздела, содержащая список разделов (максимум четыре) и расположение загрузочных секторов соответствующих логических дисков; \n2. главный загрузочный код – небольшая программа, которая выполняется системой BIOS. Основная функция этого кода – передача управления в раздел, который обозначен как активный (загрузочный). \nЗагрузочный сектор раздела содержит: \n1. блок параметров диска, в котором содержится информация о разделе (размер, количество секторов, размер кластера, метка тома и др.); \n2. загрузочный код – программу, с которой начинается процесс загрузки операционной системы. \nФайловая система FAT поддерживает всего два типа файлов: обычный файл и каталог. Файловая система распределяет память только из области данных, причем использует в качестве минимальной единицы дискового пространства кластер. \nТаблица FAT (как основная копия, так и резервная) состоит из массива индексных указателей, количество которых равно количеству кластеров области данных. Между кластерами и индексными указателями имеется взаимно однозначное соответствие – нулевой указатель соответствует нулевому кластеру и т. д. \nИндексный указатель может принимать следующие значения, характеризующие состояние связанного с ним кластера: \n• кластер свободен (не используется); \n• кластер используется файлом и не является последним кластером файла (в этом случае индексный указатель содержит номер следующего кластера файла); \n• последний кластер файла; \n• дефектный кластер; \n• резервный кластер."
        answer[35] =
            "Файловая система ОС должна предоставлять пользователям набор операций для работы с файлами,\nоформленный в виде системных вызовов. В различных ОС имеются различные наборы файловых\nопераций.\nНаиболее часто встречающиеся системные вызовы для работы с файлами:\n1. Create (создание). Файл создается без данных. Этот системный вызов объявляет о появлении\nнового файла и позволяет установить некоторые его атрибуты;\n2. Delete (удаление). Ненужный файл удаляется, чтобы освободить пространство на диске;\n3. Open (открытие). До использования файла его нужно открыть. Данный вызов позволяет\n        прочитать атрибуты файла и список дисковых адресов для быстрого доступа к содержимому\n        файла;\n4. Close (закрытие). После завершения операций с файлом его атрибуты и дисковые адреса не\nнужны. Файл следует закрыть, чтобы освободить пространство во внутренней таблице;\n5. Read (чтение). Файл читается с текущей позиции. Процесс, работающий с файлом, должен\nуказать (открыть) буфер и количество читаемых данных;\n6. Write (запись). Данные записываются в файл в текущую позицию. Если она находится в конце\nфайла, его размер автоматически увеличивается. В противном случае запись производится\nповерх существующих данных;\n7. Append (добавление). Это усеченная форма предыдущего вызова. Данные добавляются в\nконец файла;\n8. Seek (поиск). Данный системный вызов устанавливает файловый указатель в определенную\n        позицию;\n9. Get attributes (получение атрибутов). Процессам для работы с файлами бывает необходимо\nполучить их атрибуты;\n10. Set attributes (установка атрибутов). Этот вызов позволяет установить необходимые атрибуты\n        файлу после его создания;\n11. Rename (переименование). Этот системный вызов позволяет изменить имя файла. Однако\nтакое действие можно выполнить копированием файла. Поэтому данный системный вызов не\n        является необходимым;\n12. Execute (выполнить). Используя этот системный вызов, файл можно запустить на\nвыполнение."
        answer[36] =
            "Пользователи - субъекты доступа, разделяемые ресурсы – объекты. Пользователь осуществляет\nдоступ к объектам c помощью прикладных процессов, запускаемых от его имени.\nДля каждого типа объекта существует набор операций, которые можно с ним выполнять. Система\nконтроля доступа ОС должна предоставлять средства для задания прав пользователей по\nотношению к объектам дифференцированно по операциям.\nВ качестве субъектов доступа могут выступать как отдельные пользователи, так и группы\nпользователей. Объединение пользователей с одинаковыми правами в группу и задания прав\n        доступа в целом для группы - один из основных приемов администрирования в больших системах.\nУ каждого объекта доступа существует владелец. Он может выполнить с ним любые допустимые\n        для данного объекта операции. Во многих ОС существует особый пользователь – администратор\n«superuser», который имеет все права по отношению к объектам системы, не обязательно являясь\nих владельцем. Эти права необходимы администратору для управления политикой доступа.\nРазличают два основных подхода к определению прав доступа: • Избирательный доступ – ситуация, когда владелец объекта определяет допустимые\nоперации с объектом. Называется также произвольным доступом, так как позволяет\nадминистратору и владельцам объекта определить права доступа по их желанию.\nАдминистратор по умолчанию наделен всеми правами. • Мандатный доступ – подход к определению прав доступа, при котором система\n(администратор) наделяет пользователя или группу определенными правами по отношению к\n        каждому разделяемому ресурсу. Группы пользователей образуют строгую иерархию, каждая\nгруппа пользуется всеми правами группы более низкого уровня иерархии.\nМандатные системы доступа более надежные, но менее гибкие, применяются в системах с\nповышенными требованиями к защите информации.\nКаждый пользователь (группа) имеет символьное имя и уникальный числовой идентификатор. При\n        выполнении процедуры логического входа в систему пользователь сообщает свое символьное имяили пароль. Все идентификационные данные и сведения о вхождении пользователя в группы\nхранятся в специальном файле или базе данных.\nВход пользователя в систему порождает процесс – оболочку, который поддерживает диалог с\nпользователем и запускает для него другие процессы. Любой порождаемый процесс наследует\n        идентификаторы пользователя и групп от процесса родителя.\nВ самом общем случае права доступа могут быть описаны матрицей прав доступа, в которой\nстолбцы соответствуют всем файлам системы, а строки – всем пользователям. На пересечении\nстрок и столбцов указываются разрешенные операции. Матрица хранится по частям, т.е. для\nкаждого файла и каталога создается список управления доступом, где описываются права на\nвыполнение операций пользователей и групп пользователей по отношению к этому файлу или\n        каталогу. Список управления доступом - часть характеристик файла или каталога, хранится на\nдиске в соответствующей области.\nПроверки прав доступа для объектов любого типа выполняются централизованно с помощью\nмонитора безопасности, работающего в привилегированном режиме.\nДля системы безопасности Windows характерно большое количество различных встроенных\nсубъектов доступа – отдельных пользователей и групп. Они наделены определенными правами, что\nоблегчает работу администратора по созданию эффективной системы разграничения доступа. Во первых, за счет того, что нового пользователя можно внести в какую-то группу. Во-вторых, можно\nдобавлять\\изымать права встроенных групп, создавать новые группы с уникальным набором прав. "
        answer[37] =
            "• Планирование заданий - процедура выбора очередного задания для загрузки в машину, т. е.\nдля порождения соответствующего процесса; • Планирование использования процессора - впервые возникает в мультипрограммных вычислительных системах, где в состоянии готовность могут одновременно находиться\nнесколько процессов. Именно для процедуры выбора из них одного процесса, который\nполучит процессор в свое распоряжение, т. е. будет переведен в состояние исполнение.\nПланирование  заданий используется в качестве  долгосрочного планирования процессов.\nОтвечает з а порождение новых процессов в системе, определяя е е  степень\nмультипрограммирования, т. е. количество процессов, одновременно находящихся в ней.\nЕсли  степень мультипрограммирования  системы поддерживается постоянной, т. е. среднее\nколичество процессов в компьютере не меняется, то новые процессы могут появляться только после\nзавершения ранее загруженных. Поэтому  долгосрочное планирование  осуществляется достаточно\nредко, между появлением новых процессов могут проходить минуты и даже десятки минут.\nПланирование  использования процессора применяется в качестве  краткосрочного\nпланирования процессов. Оно проводится, к примеру, при обращении исполняющегося процесса к\nустройствам ввода-вывода или просто по завершении определенного интервала времени.\nПоэтому  краткосрочное планирование  осуществляется, как правило, не реже одного раза в 100\nмиллисекунд. Выбор нового процесса для исполнения оказывает влияние на функционирование\nсистемы до наступления очередного аналогичного события, т. е. в течение короткого промежутка\nвремени, чем и обусловлено название этого уровня планирования – краткосрочное.\nПромежуточный уровень планирования процессов – среднесрочный – временное удаление\nкакого-либо частично выполненного процесса из оперативной памяти на диск – swapping."
        answer[38] =
            "Для каждого уровня планирования можно предложить несколько различных алгоритмов. Выбор алгоритма планирования определяется классов задач и целями, которые необходимо достичь. К числу целей можно отнести: \n1. Справедливость – гарантирование каждому заданию или процессу части времени ЦП; \n2. Эффективность; \n3. Сокращение полного времени выполнения – сокращение времени получения результата между запуском и завершением; \n4. Сокращение времени ожидания – время между процессами; \n5. Сокращение времени отклика. \nВ качество основного параметра, который рассматривается разработчиками ОС, рассматривается время загрузки ЦП задачами пользователя. Критерии, которые показывают, что ОС работает корректно, отвечают требованиям 40-90% процессорного времени для пользовательских задач. \nНезависимо от поставленных целей  планирования  желательно, чтобы алгоритмы обладали следующими свойствами: \n• Были предсказуемыми; \n• Были связаны с минимальными накладными расходами; \n• Равномерно загружали ресурсы вычислительной системы, отдавая предпочтение тем процессам, которые будут занимать малоиспользуемые ресурсы; \n• Обладали масштабируемостью, т.е. не сразу теряли работоспособность при увеличении нагрузки."
        answer[39] =
            "Все параметры планирования можно разделить на 2 большие группы:\n1. Статистические\na. Каким пользователем был запущен процесс. С точки зрения запуска пользователем ОС всегда отдает предпочтение пользовательским задачам, далее следуют задачи локальной\nсистемы, далее – локальная служба, далее – сетевая служба.\nb. Приоритет выполнения.\nc. Сколько процессорного времени запрошено для решения задач. Оценка времени\n        выполнения по каким-либо критериям.\nd. Какого соотношение процессорного времени, необходимого для осуществления\nоперации ввода/вывода. В первую очередь зависит от времени прерывания для самой\n        операции ввода/вывода, а также от устройств, который занимаются вводов/выводом.\ne. Какие ресурсы вычислительной системы. ОП, ЦП.\n2. Динамические\na. Количество времени с момента выгрузки процесса на диск или загрузки в оперативную\n        память.\n        b. Сколько оперативной памяти занимает процесс.\nc. Сколько процессорного времени уже предоставлено процессу.\nCPU burst – промежуток времени непрерывного использования процессора, а промежуток\nвремени непрерывного использования операции ввода/вывода называется I/O burst. Они так же\n        относятся к динамическому планированию.\nДолгосрочное и среднесрочное планирование используют как динамические, так и\nстатические параметры планирования, но больше ориентируется на статическое планирование.\nПланирование ввода/вывода и краткосрочное планирование не используют статику, а используют\nтолько динамические параметры. "

        quest[0] = "Большинство современных компьютеров состоит из двух и более уровней."
        quest[1] =
            "Принципиально важными универсальными подходами к разработке архитектуры ОС являются."
        quest[2] = "В современных операционных системах различают следующие виды ядер. "
        quest[3] = "К ОС предъявляется ряд важных эксплуатационных требований."
        quest[4] =
            "Концепция процессов и потоков. Задание, процессы, потоки (нити), волокна. Методы взаимоисключений."
        quest[5] = "Управление процессами и потоками. Взаимоблокировки. "
        quest[6] = "Планирование заданий, процессов и потоков."
        quest[7] = "Организация памяти современного компьютера."
        quest[8] = "Распределение памяти."
        quest[9] = "Оптимизация функционирования страничной виртуальной памяти."
        quest[10] = "Назначение операционных систем."
        quest[11] =
            "Многослойная структура ядра ОС может быть представлена, например, вариантом, показанным(кольцо)."
        quest[12] =
            "Все многообразие существующих (и ныне не использующихся) ОС можно классифицировать по множеству различных признаков."
        quest[13] = "Эффекты виртуализации."
        quest[14] = "Мультипрограммирование. Формы многопрограммной работы. Семафоры и мониторы. "
        quest[15] = "Создание процессов и потоков. Модели процессов и потоков. Системные вызовы."
        quest[16] = "Взаимодействие и синхронизация процессов и потоков."
        quest[17] = "Функции ОС по управлению памятью. "
        quest[18] = "Страничная организация виртуальной памяти."
        quest[19] = "Сегментная организация виртуальной памяти."
        quest[20] = "Назначение, задачи и технологии подсистемы ввода-вывода."
        quest[21] = "Согласование скоростей обмена и кэширования данных."
        quest[22] = "Разделение устройств и данных между процессами."
        quest[23] =
            "Обеспечение логического интерфейса между устройствами и системой. Динамическая загрузка и выгрузка драйверов."
        quest[24] = "Поддержка широкого спектра драйверов."
        quest[25] = "Поддержка синхронных и асинхронных операций ввода-вывода."
        quest[26] = "Многослойная (иерархическая) модель подсистемы ввода-вывода. "
        quest[27] = "Драйверы."
        quest[28] = "Файловые системы. Основные понятия."
        quest[29] = "Архитектура файловой системы."
        quest[30] = "Организация файлов и доступ к ним."
        quest[31] = "Каталоговые системы."
        quest[32] = "Физическая организация файловой системы."
        quest[33] = "Физическая организация и адресация файла."
        quest[34] = "Физическая организация FAT-системы."
        quest[35] = "Файловые операции."
        quest[36] = "Контроль доступа к файлам."
        quest[37] = "Уровни планирования."
        quest[38] = "Критерии планирования и требования к алгоритмам."
        quest[39] = "Параметры планирования."
    }
}
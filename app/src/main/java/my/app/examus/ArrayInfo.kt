package my.app.examus

import kotlin.properties.Delegates

private var answer = arrayOfNulls<String>(64)
private var quest = arrayOfNulls<String>(64)
private var maxId = 0
private var mode = 0

class ArrayInfo {

    fun generateFromMode(mode_: Int) {
        mode = mode_
        if (mode == 1) {
            maxId = 63
        }
        if (mode == 2) {
            maxId = 2
        }
        arrayInfoGenerate()
    }

    fun getMaxId():Int{
        return maxId
    }

    fun getQuestion(num: Int): String? {
        return quest[num]
    }

    fun getAnswer(num: Int): String? {
        return answer[num]
    }
}

fun arrayInfoGenerate() {
    when (mode) {
        1 -> {
            answer[0] =
                "На 0 уровне находится аппаратное обеспечение. Этот уровень воспринимает ТОЛЬКО команды машинного языка.\nНа 1 уровне находится микроархитектура. На этом уровне можно работать с совокупностью регистров, разрядность которых на текущий момент х32 или х64, и АЛУ.\n2 уровень составляет уровень архитектуры системы команд. На этом уровне уже могут выполняться машинные команды ассемблера.\n3 уровень – гибридный.На нем и находится ОС, которая позволяет выполнять системные вызовы, макросы или работать в режиме super визора.Все следующие уровни предназначены для прикладных программистов."
            answer[1] =
                "Принципиально важными и универсальными подходами к разработке архитектуры ОС являются:\n1. Модульная организация;\n2. Функциональная избыточность;\n3. Функциональная избирательность;\n4. Параметрическая универсальность;\n5. Концепция многоуровневой иерархической вычислительной системы;\n6. Разделение модулей на два группы: ядро и пользовательские;\n7. Разделение модулей по размещению в памяти на резидентные и транзитные;\n8. Реализация двух режимов работы: user mode и kernel mode;\n9. Ограничение функций ядра.\nВ любой ОС количество модулей User mode всегда больше, чем количество модулей Kernel mode.\nПрограммы с приоритетом “0” выполняются на уровне Kernel mode. В kernel должно быть как можно меньше модулей. "
            answer[2] =
                "1. Наноядро – крайне упрощенное и минимальное ядро, которое выполняет только 1 задачу – обработку аппаратных прерываний (предназначено для управления простейшими техническими объектами, такими как умные карты или умные ключи для автомобилей)\n2. Микроядро – представляет собой элементарные функции управления процессами и минимальный набор абстракций для работы с оборудованием (предназначено для управления дата-центрами, оно не способно даже на примитивный уровень защиты)\n3. Экзоядро – представляет собой набор сервисов для взаимодействия между приложениями (также предназначено для управления сложными техническими объектами, которые требуют отклика за строго отведенное время, например разведение мостов, управление атомной станции; на этом ядре работают операционные системы реального времени)\n4. Монолитное ядро – представляет собой широкий набор абстракций, все части ядра работают в одном адресном пространстве (используется в настоящее время в ОС, которые обслуживают микрокомпьютеры, каждая сборка работает на строго отведенном оборудовании и в случае изменения аппаратной конфигурации требуется полная пересборка всего ядра; в случае с монолитным ядром чаще всего вся ОС может содержаться в оперативной памяти, не используя для этого отдельный жесткий диск)\n5. Модульное ядро – современное, усовершенствованная модификация монолитного ядра, в отличие от классических монолитных ядер не требует полной перекомпиляции при изменении состава аппаратного обеспечения (предназначено для большинства современных ОС; при использовании модульного ядра основное требование заключается в том, чтобы наследники отвечали тем же требованиям, что и существующий модуль)\n6. Гибридное ядро – модифицированное микроядро, позволяющее запускать несущественные части в пространстве ядра (работает по тому же принципу, что и модульное ядро)\n7. Второе гибридное ядро – наиболее тесно связаны элементы микроядерной архитектуры и элементы монолитного ядра (в настоящее время второе гибридное ядро не используется)"
            answer[3] =
                "1. Эффективность. Эффективность ОС оценивается как количество выполненных пользовательских задач к общему количеству выполненных задач за один квант времени;\n2. Надежность и отказоустойчивость считается как количество событий, пришедших к краху ОС к общему количеству ошибок за один квант времени; 3. Безопасность ОС считается как количество успешно отраженных атак к общему количеству атак за один квант времени. Kali Linux – система для тестирования безопасности;\n4. Предсказуемость ОС — это количество одинаково выполненных задач к общему количеству задач за один квант времени;\n5. Расширяемость ОС – количество модулей, которые потенциально можно добавить к общему количеству модулей;\n6. Переносимость ОС – количество устройств, на которых она может работать без дополнительной настройки общему количеству устройств;\n7. Совместимость (коэффициент) есть количество приложений, которые она потенциально может выполнить к общему количеству приложений;\n8. Удобство ОС есть коэффициент количества спрогнозированных самим пользователем действий к общему количеству действий;\n9. Масштабируемость – количество корректно используемого оборудования к общему количеству оборудования в рамках одной конфигурации."
            answer[4] =
                "Процесс – абстрактное понятие, описывающих работу программы. Всё функционирующее на компьютере ПО, включая саму ОС, можно представить набором процессов. Процесс рассматривается ОС как заявка или контейнер для всех видов ресурсов, кроме процессорного времени. Этот ресурс распределяется ОС между другими единицами работы – потоками, которые представляют собой последовательность или поток выполнения определенных команд.\nЕсли основной поток часто появляется в очереди на обработку и при этом с ним ничего не происходит, ОС считает зависшим такой поток и его процесс.\nДлительные действия с точки зрения процесса всегда должны выполняться отдельными потоками. Работа основного потока в ОС не должна сильно страдать, если не выполняется работа дочерних потоков.\nКаждый процесс должен считать себя уникальным в оперативной памяти. Прямой доступ к оперативной памяти другого процесса – нарушение условий функционирования и безопасности с точки зрения ОС.\nС точки зрения процесса, инкапсуляция – защита оперативной памяти самого процесса и предоставление методов для работы с ней.\nНаследование, с точки зрения процессов – создание отдельных процессов для выполнения каких-либо задач и закрепления родителя.\nКорректная модель наследования требует, чтобы любой процесс, порожденный от другого процесса, являлся его наследником. В противном случае не реализуется один из базовых механизмов операционной системы.\nПолиморфизм, с точки зрения процессов, реализуется как возможность работать как с одним типом параметров, так и с другим.\nВзаимоисключение (когда 2 процесса, обратившись к ресурсу и не получив доступа, должны быть оба остановлены одновременно или остановлен только один)\nМетоды взаимоисключений:\nДля организации взаимоисключений критических участков существует 5 основных условий, которые должны выполняться для каждого процесса:\n1. Задача должна быть решена чисто программным способом на обычной машине, не имеющей специальных команд взаимоисключения;\n2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов, потому что этот процесс слишком непредсказуем;\n3. Если процесс, выполняется в своем критическом участке, то не должно существовать других процессов, которые выполняются в подобных критических участках;\n4. Процессы, которые находятся вне своих критических участков и не собираются в них входить, не должны препятствовать другим процессам входить в их критические участки;\n5. Не должно возникать бесконечного ожидания для входа в свой критический участок.\nОС единообразно работает со всеми неразделяемыми ресурсами, а любое физическое устройство – это чаще всего неразделяемый ресурс."
            answer[5] =
                "Подсистема управления процессами и потоками - основная подсистема в современных ОС. Ее основные функции:\n1. Создание процессов и потоков; 2. Обеспечение процессов и потоков необходимыми ресурсами;\n3. Изоляция процессов. С точки зрения изоляции процессов, общение процессов напрямую без использования API операционной системы, является нарушением безопасности в рамках ОС.\nЕсли процессы начинают общаться между собой без использования API ОС, то они могут напрямую общаться с ресурсами и менеджерами ресурсов в рамках данного процесса, что является нарушением безопасности ОС;\n4. Планирование выполнения процессов и потоков;\n5. Диспетчеризация процессов и потоков – сравнение запланированных задач и выполненных. В  ОС существуют транзакционное выполнение потоков, в этом случае поток должен выполниться до определенной точки, если этого не происходит, ОС откатывает состояние потока в первоначальное и повторяет попытку выполнения;\n6. Организация межпроцессного взаимодействия;\n7. Синхронизация процессов и потоков;\n8. Завершение процессов и потоков.\nТупиковая ситуация (взаимоблокировка) – когда два и более процесса удерживают и бесконечно ожидают необходимые для выполнения ресурсов. Для возникновения такой ситуации необходимо выполнение одновременно 4 условий:\n1. Условия взаимного исключения;\n2. Условия удержания и ожидания;\n3. Условие отсутствия принудительной выгрузки ресурсов;\n4. Условия циклического ожидания.\nПравила правильного программирования требуют: если ресурс, который необходим для выполнения того или иного действия, занят другим процессом, выполнение действия необходимо отложить, а занятые ресурсы - освободить. То есть для нестатичного класса – если он захватывает ресурсы, обязательно должен быть dispose.\nПри столкновении с взаимоблокировкой или тупиком, существуют 4 основные стратегии:\n1. Обнаружение и восстановление (нашли, восстановили работу);\n2. В ОС вторая стратегия – структурное опровержение (пр. виртуализация ресурсов) одного из 4 условий возникновения тупиковой ситуации;\n3. Пренебрежение проблемы в целом;\n4. Аккуратное распределение и планирование ресурсов. "
            answer[6] =
                "Основная цель планирования вычислительного процесса - распределение времени процессора между выполняемыми процессами. Все виды планирования, используемые в современных ОС, делятся на:\n1. Долгосрочное планирование принимает решение о добавлении процесса в пул выполняемых. Чаще всего долгосрочный планировщик не влияет на пользовательские процессы, только если занято не менее 80% оперативной памяти.\n2. Среднесрочное планирование принимает решение о добавлении процесса к числу процессов, полностью или частично размещенных в основной памяти. Этот планировщик работает для всех процессов, включая пользовательские. Его работу можно заметить, если запускать одновременно много процессов.\n3. Краткосрочное планирование принимает решение о том, поток какого процесса будет выполняться.\n4. Планирование ввода/вывода принимает решение о том, операция какого процесса или потока будет выполняться свободным устройством ввода/вывода. Заключается в выстраивании ОС порядка выполнения критических секций или критический областей.\nВ мультипрограммной системе поток может меняться, если:\n1. Поток завершился и покинул систему;\n2. Произошла ошибка;\n3. Поток перешел в состояние ожидания;\n4. Исчерпан квант времени.\nЕсли происходит ситуация завершения потока с ошибкой или без, то ОС реагирует на такую ситуацию одинаково - полностью перестаивая очередь от момента завершения активного потока.\nВ момент ожидания ввода/вывода ОС создает новый поток, который становится в очереди на выполнение очень близко к выполняющемуся, пропустив только привилегированные потоки."
            answer[7] =
                "Память – важнейший ресурс вычислительной системы, требующий аккуратного распределения для выполнения следующих пунктов: 1. Модули создавались и компилировались независимо друг от друга;\n2. Разные степени защиты модулей - с помощью API ОС можно в рамках своего процесса создать закрытую область памяти, доступ в которую будет иметь только ваш процесс;\n3. Возможно применение механизмов для совместного использования одних и тех же модулей.\nКогда мы пишем использование общих модулей, ОС не создает отдельно в памяти для каждого процесса их экземпляр. Существует область в памяти и процесс, который за это отвечает. При обращении к таким модулям запрос приходит синхронно. А область, к которой мы обращаемся, работает в асинхронном режиме, создавая отдельные потоки или процессы для решения нашей задачи.\nОсновной закон по памяти гласит: программы, расширяясь, стремятся заполнить весь доступный объем. Это выводит следующие устойчивые соотношения:\n1. Чем меньше время доступа, тем дороже бит. Выполняется в тот момент, когда несколько процессов попеременно обращаются к одному и тому же куску оперативной памяти. При этом чем быстрее происходит обращение и выгрузка, тем больше процессов могут работать с одним и тем же куском.\n2. Чем выше ёмкость, тем ниже стоимость бита. Не надо выгружать в файл подкачки и становится не важно сколько оперативной памяти занято.\n3. Чем выше ёмкость, тем больше время доступа. Если оперативной памяти становится очень много, ОС делит процесс на большое количество участков, и выгрузка, и возвращение процесса на его место занимает продолжительное время.\nВиртуализация памяти (прослойка между оперативной памяти и жестким диском) возможна с помощью 2-х методов:\n1. Swaping (выгружает весь процесс на ЖД). По сравнению с виртуальной памятью 2 основных недостатка:\na. Избыточность перемещаемых данных;\nb. Невозможность загрузить процесс, виртуальное пространство которого превышает свободную память.\nДостоинство Swaping’a заключается в скорости преобразования виртуальных адресов в реальные.\n2. Виртуальная память (выгружает процесс частями на ЖД)."
            answer[8] =
                "Методы распределения памяти относительно процессов:\n• С использованием внешней памяти:\n• Страничное перемещение;\n• Сегментное перемещение;\n• Странично–сегментное перемещение.\n• Без использования внешней памяти (Нет места механизму виртуализации. ОС для каждого символьного имени настраивает реальные физические адреса):\n• Фиксированные разделы - память выделяется процессом одними и теми же кусками, вне зависимости от размера сохраняемых данных;\n• Динамические разделы – разделы, начальный и конечный адрес которых ОС определяет в момент инициализации переменных;\n• Перемещаемые разделы –изначально делятся в динамические, а после этого разделяются на фиксированные. "
            answer[9] =
                "Методы повышения эффективности функционирования страничной виртуальной памяти:\n1. Более сложная структуризация виртуального адресного пространства (например, двухуровневая -типичная для 32-битовой адресации).\n2. Использование специального высокоскоростного кэша для хранения части записей таблицы страниц, который обычно называют буфером быстрого преобразования адреса, или буфером поиска трансляции (translation lookaside buffer – TLB);\n3. Выбор оптимального размера страницы виртуальной памяти;\n4. Эффективное управление страничным обменом."
            answer[10] =
                "Назначение ОС можно разделить на 4 основные составляющие: 1. Организация удобного интерфейса меду приложениями и пользователями с одной стороны и аппаратурой компьютера с другой. В этот пункт входят следующие сервисы: \na) Разработка программы;\nb) Исполнение программы;\nc) Доступ к устройствам ввода\\вывода;\nd) Контролируемый доступ к файлам;\ne) Системный доступ;\nf) Обнаружение ошибок и их обработка;\ng) Учет использования ресурсов.\n2. Организация эффективного использования ресурсов компьютера:\na) Планирование ресурса;\nb) Удовлетворение запроса на ресурс – решается механизмом блокировок;\nc) Отслеживание состояния и учет использования ресурса;\nd) Разрешение конфликтов между процессами, претендующими на один и тот же ресурс.\n3. Облегчение процессов эксплуатации аппаратных и программных средств:\na) Диагностика;\nb) Средство восстановления последней работоспособной конфигурации;\nc) Средство восстановления поврежденных файлов.\n4. Возможность развития:\na) Обновление аппаратного перечня;\nb) Новые сервисы и исправления."
            answer[11] =
                "1. Средства аппаратной поддержки ОС. Система прерываний, средства поддержки привилегированного режима, средства поддержки виртуальной памяти, системный таймер, информация о состоянии процесса в момент его приостановки, средства защиты памяти и др.\n2. Машинно-зависимые модули ОС. Этот слой образует модули, в которых отражается\nспецифика аппаратной платформы компьютера. Назначение этого слоя – «экранирование» вышележащих слоев ОС от особенностей аппаратуры.\n3. Базовые механизмы ядра. Этот слой модулей выполняет наиболее примитивные операции ядра: программное переключение контекстов процессов, диспетчерскую прерываний, перемещение страниц между основной памятью и диском и т.п. Модули этого слоя обрабатывают решения, принятые модулями вышележащих уровней.\n4. Менеджеры ресурсов. Модули этого слоя выполняют стратегические задачи по управлению ресурсами вычислительной системы. Это менеджеры процессов ввода-вывода, оперативной памяти и файловой системы. Каждый менеджер ведет учет свободных и используемых ресурсов и планирует их распределение в соответствии запросами приложений.\n5. Интерфейс системных вызовов. Это верхний слой ядра ОС, взаимодействующий с приложениями и системными утилитами, он образует прикладной программный интерфейс ОС. Функции API, обслуживающие системные вызовы, предоставляют доступ к ресурсам системы в удобной компактной форме, без указания деталей их физического расположения."
            answer[12] =
                "1. по назначению:\na. универсальные – подходят для решения практически любых задач;\nb. специализированные – имеют ограниченный круг задач.\n2. по особенностям алгоритмов управления ресурсами:\na. поддержка многозадачности - современные ОС являются многозадачными;\nb. поддержка многопользовательского режима - современные ОС являются многопользовательскими;\nc. многопроцессорная обработка;\nd. виды многопрограммной работы: не вытесняющие многозадачность и вытесняющие\nмногозадачность. Современные ОС широкого использования являются вытесняющими ОС.\n3. по способу загрузки в оперативную память:\na. загружаемые ОС - все классические ОС являются загружаемыми;\nb. постоянно находящиеся ОС.\n4. по области использования и форме эксплуатации:\na. системы пакетной обработки - смысл заключается в необходимости обсчета определенных данных, и пока он не завершается, ОС не занимается другими задачами;\nb. разделение времени - современные классические ОС являются системами разделения времени;\nc. реального времени.\n5. по аппаратной платформе:\na. ОС для смарт-карт;\nb. встроенные ОС (BIOS);\nc. для ПК (планшетов, телефонов и тд);\nd. для мини-ЭВМ;\ne. для мэйнфреймов;\nf. серверные ОС;\ng. кластерные ОС. "
            answer[13] =
                "Виртуализация ́— предоставление набора вычислительных ресурсов или их логического объединения, обеспечивающее при этом логическую изоляцию друг от друга вычислительных процессов, выполняемых на одном физическом ресурсе.\nВиртуализация позволяет отделить ПО от низлежащей аппаратной инфраструктуры. Разрывает связь между определенным набором команд и конкретным компьютером. Обеспечивает высокий уровень работоспособности и безопасности благодаря нескольким ключевым возможностям.\nЛокализация неисправностей. Большинство отказов приложений происходят из-за ошибок ПО.\nВиртуализация обеспечивает логическое разделение виртуальных разделов, поэтому программный сбой в одном разделе никак не влияет на работу приложения в другом разделе. Логическое разделение также позволяет защищаться от внешних атак, что повышает безопасность консолидированных сред.\nГибкая обработка отказов. Виртуальные разделы можно настроить так, чтобы обеспечить автоматическую обработку отказов для одного или нескольких приложений. Благодаря средствам\nобеспечения высокой степени работоспособности, требуемый уровень услуг часто можно обеспечить, предусмотрев аварийный раздел на той же платформе, где работает основное приложение. Если требуется еще более высокий уровень работоспособности, аварийный раздел можно разместить на отдельной платформе.\nРазные уровни безопасности. Для каждой виртуальной машины можно установить разные настройки безопасности.\nГибкость управления ресурсами, которую обеспечивают МВМ (малая вычислительная машина), может сделать системы более стойкими к нападениям.\nВиртуализация предоставляет также преимущества для сред разработки и тестирования ПО.\nРазличные этапы цикла создания ПО, включая получение рабочей версии, можно выполнять в разных виртуальных разделах одной и той же платформы. Это поможет повысить степень полезного использования аппаратного обеспечения и упростить управление жизненным циклом.\nВиртуализация позволяет обойти несовместимость разных интерфейсов. Виртуализация системы или компонента подсистема управления процессами и потоками на конкретном уровне абстракции отображает его интерфейс и видимые ресурсы на интерфейс и ресурсы реальнойсистемы. Следовательно, реальная система выступает в роли другой, виртуальной системы или даже нескольких виртуальных систем."
            answer[14] =
                "Мультипрограммирование – способ организации вычислительного процесса, при котором на одном процессоре попеременно выполняются несколько программ. Чтобы поддержать мультипрограммирование, ОС разделяет для себя процессы на внутренние единицы, которые и обрабатываются на процессоре. На большинстве ОС крупной единицей считается процесс или задача, менее крупной – поток или нить. Наиболее характерными показателями эффективности вычислительных систем являются: \n1. Пропускная способность – количество задач, которые может решать ОС за одну единицу времени. Стоимость в каждой задаче для пропускной способности усредняется; \n2. Удобство работы пользователей – возможность одновременной работы с несколькими приложениями на одной машине; \n3. Реактивность системы – способность выдерживать заранее заданные интервалы времени между запуском программы и получением конечного результата. В зависимости от выбора одного из этих показателей эффективности, ОС делятся на: \n• Системы пакетной обработки – пренебрегают всеми характеристиками, кроме реактивности системы. А количество времени, которое ОС потратит на решение задачи должно быть строго выдержано. \n• Системы разделения времени –возможность интерактивной работы сразу с несколькими приложениями, для этого приложения должно регулярно получать возможность общения с пользователем. Это решается за счет того, что ОС принудительно останавливает приложения. Все привычные нам ОС - разделения времени. Главным показателем является удобство работы пользователя и пропускная способность, реактивность системы отходит на второй план. В ОС разделения времени приоритет отдается тем процессам, которые в настоящее время «ведут общение с пользователем». \n• Системы реального времени – предназначены для управления техническими объектами, технологическими процессами и системами массового обслуживания. Для данной ОС главной характеристикой является реактивность, потому что время выполнения задачи строго регламентировано и не должно увеличиваться.\nСемафор - целая переменная, принимающая неотрицательные значения. Доступ любого процесса к ней, за исключением момента ее инициализации, может осуществляться только через две атомарные операции: \nP (proberen – проверять) и V (от verhogen – увеличивать). Классическое определение этих операций выглядит следующим образом: \nP(S): пока S == 0 процесс блокируется; \nS = S - 1;\n V(S): S = S + 1;\nПри выполнении операции P над семафором S, проверяется его значение. \nЕсли оно > 0, то из S вычитается 1. Если оно < или = 0, процесс блокируется, пока S не станет > 0, после чего из S вычитается 1. \nПри выполнении операции V над семафором S к его значению просто прибавляется \n1. Мониторы - тип данных, который может быть с успехом внедрен в языки ООП. Обладает собственными переменными, определяющими его состояние. Их значения извне монитора могут быть изменены только с помощью вызова функций-методов, принадлежащих ему. Эти функции-методы могут использовать данные, находящиеся внутри монитора, и свои параметры. Важная особенность мониторов - в любой момент времени только один процесс может быть активен, т. е. находиться в состоянии \"готовность\" или \"исполнение\", внутри данного монитора. Поскольку мониторы представляют собой особые конструкции языка программирования, компилятор может отличить вызов функции, принадлежащей монитору, от вызовов других функций и обработать его специальным образом, добавив к нему пролог и эпилог, реализующий взаимоисключение."
            answer[15] =
                "Создание процессов и потоков приводит 5 основных событий:\n1. инициализация ОС; 2. выполнение запроса работающего процесса на создание нового;\n3. запрос пользователя на создание процесса;\n4. инициирование пакетного задания;\n5. создание процесса для выполнения какой-либо службы.\nВ момент старта процесса весь исполняемый код загружается в оперативную память для последующего исполнения. Если есть блокирующий код, это будет отдельный поток. При создании\nпроцесса всегда создается основной поток, выполняющий весь код, если не предусмотрена мультипоточность. Только блокирующий ввод/вывод создается в виде отдельных потоков. Он создается отдельными потоками, чтобы основной не переходил на уровень kernel, так как чаще всего в этом нет необходимости.\nИнформация по состоянию и управлению процессом включает следующие основные данные:\n1. идентификатор процесса (GUID, содержит 36 символов: буквы в нижнем регистре, цифры, и\nтире);\n2. индекс процесса (число);\n3. состояние процесса;\n4. данные о приоритете (число);\n5. информация о событиях – массив или список всех событий, которые совершены за один сеанс работы. Тот список, который ОС показывает при просмотре событий является виртуальной таблицей, которая содержит описание события. В реальной таблице описание не хранится;\n6. указатели на оперативную память и жесткий диск – содержат следующую информацию (в отдельной таблице):\na. индекс процесса;\nb. начальные адрес в оперативной памяти;\nc. конечный адрес в ОП;\nd. начальный адрес на жестком диске;\ne. конечный адрес на ЖД.\n7. указатели на ресурсы – это так же отдельная таблица, в которой хранится информация по ресурсам, которые заблокировал процесс в настоящее время;\n8. указатели на другие процессы – в таблице, которая хранит на другие процессы содержится информация о родителе процесса. В момент завершения процесса все его живые потомки\nпереходят на уровень самого процесса;\n9. флаги, сигналы и сообщения, имеющие отношение к обмену информации между независимыми процессами;\n10. данные о привилегиях – в отличии от приоритета данные о привилегиях содержатся в отдельной таблице и могут иметь разное значение на различные ресурсы. В таблице привилегий содержится информация как о запретах, так и о разрешениях на те или иные ресурсы;\n11. сведения по истории использования ресурсов;\n12. информация, связанная с планированием.\nВ таблице процессов хранятся только активные процессы. Максимально возможное время хранение завершенного процесса в этой таблице – 30 секунд. (Чистит процессы фоновое задание)\nУ процесса могут быть следующие состояния:\n1. выполняющийся;\n2. готовый к выполнению;\n3. ожидающий какого-либо события;\n4. приостановленный.\nСостояние процесса, в котором он ожидает какого-либо события, чаще всего является состояниями ожидания ввода/вывода. Состояние приостановленного – ожидание очереди на выполнение. В ОС существует 2 способа выполнения потоков:\n1. на уровне пользователя (ULT – user level threads);\n2. на уровне ядра (KLT – kernel level threads). В ОС разделения времени потоки работают на уровне пользователя и только в случае строгой необходимости переходят на уровень ядра. Преимущества при работе потоков на уровне пользователя:\n1. производительность;\n2. различные алгоритмы планирования;\n3. применимость для любой ОС.\nНедостатки:\n1. количество потоков;\n2. отсутствие возможности принудительно забрать ЦП;\n3. не всегда можно пользоваться преимуществами многопроцессорной системы.\nСистемный вызов позволяет приложению обратиться к ОС с просьбой выполнить действие, оформленное как процедура кодового сегмента ОС. В этом плане для прикладного программиста ОС представляется некоторой библиотекой, имеющей набор различных функций, с помощью которых можно упростить прикладную программу или выполнить действия, запрещенные в пользовательском режиме.\nРеализация системных вызовов должна удовлетворять следующим требованиям:\n• обеспечивать переключение в привилегированный режим;\n• обладать высокой скоростью вызова процедур ОС;\n• обеспечивать по возможности единообразное обращение к системным вызовам для всех\n    аппаратных платформ, на которых работает ОС;\n• допускать простое расширение системных вызовов;\n• обеспечивать контроль со стороны ОС за корректным использованием системных вызовов."
            answer[16] =
                "В ОС существуют 3 способа взаимодействия процессов и потоков:\n1. Конкуренция - процессы не осведомлены друг о друге. Возможно появление трех основных проблем:\na. взаимоблокировки (2 процесса обращаются к 1 неразделяемому ресурсу);\nb. взаимоисключение (2 процесса, обратившись к ресурсу и не получив доступа, должны быть оба остановлены одновременно или остановлен только один);\nc. голодание (отсутствие ресурса, необходимого для выполнения задачи).\n2. Процессы косвенно осведомлены друг о друге. Проблемы:\na. Взаимоисключения;\nb. Взаимоблокировки;\nc. Голодание;\nd. Синхронизация.\n3. Процессы непосредственно осведомлены друг о друге\na. Взаимоблокировки;\nb. Голодание.\nЕсли процессы требуют доступ к одному неразделяемому ресурсу, такой ресурс называется критическим ресурсом, а использующая его часть программы - критическим разделом или критической секцией."
            answer[17] =
                "1. Учет свободной и занятой памяти;\n2. Первоначальное и динамическое выделение памяти процессам и освобождение памяти по завершению;\n3. Настройка адресов программы на конкретную область физической памяти; 4. Полное или частичное вытеснение кодов и данных процессов на жесткий диск;\n5. Защита памяти;\n6. Дефрагментация памяти.\nМеханизм виртуальных адресов применяется для отслеживания свободной и занятой памяти. Он позволяет для одного символьного имени создать один и более виртуальный адрес, который может распределяться на множество физических.\nОС контролирует физические адреса, для динамического выделения создаются новые виртуальные адреса.\nИспользование ссылок на переменные и оперативную память требуют наличия обходного пути.\nПри полном или частичном вытеснении изначальная ОС давно не используемые виртуальные адреса.\nС целью защиты памяти соответствие виртуального и физических адресов получить от ОС невозможно.\nДефрагментация – это фоновое задание, которое запускается раз в 20-30 секунд."
            answer[18] =
                "Страничная виртуальная память организует перемещение данных между основной памятью и диском страницами, а именно частями виртуального адресного пространства фиксированного и сравнительного небольшого размера. Размер страницы определяется в байтах по степени двойки.\nЗапись таблицы страниц содержит следующую информацию:\n1. Номер физической страницы;\n2. Признак присутствия;\n3. Признак обращения;\n4. Признак модификации;\n5. Другие управляющие биты.\nСтратегии управления страничным обменом между ЖД и оперативной памятью:\n1. Стратегия выборки («когда?») – предварительная выборка, которая подготавливает данные подпроцесса до того, как процесс запросил оперативную память. (Используется в windows)\n2. Стратегия размещения («где?») – находит первый подходящий раздел, либо первые страницы, которые схожи по запрашиваемой памяти. (Используется в windows)\n3. Стратегия замещения (FIFO);\n4. Управление резидентным множеством – работает по принципу фиксированного размера, переменного размера, локальной и глобальной зоной видимости. В случае с резидентным множеством, мы используем те страницы, которые требуют процесс самостоятельно.\n5. Стратегия очистки - выполняется по требованию или предварительно. (Используется в windows)\n6. Управление загрузкой (рабочее множество – 50%) – находит 50% и затем остальные 50%\nочищает."
            answer[19] =
                "Сегмент - множество полностью независимых адресных пространств. Каждый сегмент содержит линейную последовательность адресов от 0 до некоторого максимума. Различные сегменты могут быть различной длины, Изменяющейся во время выполнения. Поскольку каждый сегмент составляет отдельное адресное пространство, разные сегменты могут расти и сокращаться независимо друг от друга. Является логическим объектом.\nПреимущества сегментированной памяти:\n• простота компоновки отдельно скомпилированных процедур (обращение к начальной точке процедуры осуществляется адресом вида (n,0), где n – номер сегмента);\n• легкость обеспечения дифференцируемого доступа к различным частям программы (например, запретить обращаться для записи в сегмент программы);\n• простота организации совместного использования фрагментов программ различными процессами, например, библиотеки совместного доступа могут быть оформлены в виде отдельного сегмента, который может быть включен в виртуальное адресное пространство нескольких процессов.\nТаблица сегментов процесса содержит:\n• базовый физический адрес начала сегмента в оперативной памяти;\n• размер сегмента;\n• правила доступа к сегменту;\n• признаки модификации, присутствия и обращения к данному сегменту, а также некоторая другая информация.\nНедостатки:• использование операции сложения вместо конкатенации замедляет процедуру преобразования виртуального адреса в физический; \n• большая избыточность перемещения данных между диском и оперативной памятью, поскольку перемещаются целиком большие сегменты. Во многих случаях было бы достаточно загружать и выгружать одну или несколько страниц;\n• внешняя фрагментация, возникающая из-за произвольных размеров сегментов."
            answer[20] =
                "Функции подсистемы ввода/вывода:\n1. Организация параллельной работы устройств ввода/вывода и процессора;\n2. Согласование скоростей обмена и кэширования данных;\n3. Разделение устройств и данных между процессами;\n4. Обеспечение удобного логического интерфейса между устройствами и остальной частью системы;\n5. Поддержка широкого спектра драйверов;\n6. Динамическая загрузка и выгрузка драйверов;\n7. Поддержка различных файловых систем;\n8. Поддержка синхронных и ассинхронных операций ввода/вывода.\nСпособы выполнения операций ввода\\вывода:\n1. Программируемый ввод/вывод - для ЦП передается команда, он её выполняет>, посылая команды контроллеру ввода/вывода. Это устройство выполняет необходимые действия, устанавливает соответствующие биты в регистрах, в том числе состояние, но не может посылать никаких команд, в том числе прерывания, это выполняет ЦП.\n2. Ввод/вывод, управляемый прерываниями. В этом случае процессор посылает необходимые команды контроллеру ввода/вывода, продолжая выполнять текущий процесс, и если нет необходимости в ожидании операции ввода/вывода, то процесс не приостанавливается до получения сигнала прерывания.\n3. Прямой доступ к памяти (DMA – Direct Memory Access). В случае использования прямого доступа к памяти специальный модуль управляет обменом между основной памятью и контроллером ввода/вывода. В этом случае процессор посылает запрос на передачу блока данных модулю, а прерывание происходит по необходимости только после передачи всего блока."
            answer[21] =
                "При обмене данных всегда возникает задача согласования скоростей работы устройств.\nРешением этой задачи является буферизация, то есть все данные сначала помещаются в оперативную память.\nДля согласования скоростей используется буферизация на ЖД с помощью спул-файлов, либо используется буферная память самих устройств. В этом случае ОС сразу передает данные из оперативной памяти в буфер внешнего устройства, очищая при этом оперативную память.\nВ случае, если используется ОЗУ + файл подкачки - это либо одинарная, либо двойная буферизация. Второй случай предполагает циклическую буферизацию."
            answer[22] =
                "Задача разделения данных и устройств ввода/вывода между процессами заключается в решении двух подзадач:\n1.Подзадача монопольного доступа;\n2.Подзадача разделения между несколькими процессами - решается с помощью блокировки части ресурса от изменений другими процессами.\nОдно и то же устройство в разные периоды времени может работать в разделяемом и в монопольном режимах.Для некоторых характерен только один из них.\nВ случае совместного использования ОС должна оптимизировать последовательность операций ввода\\вывода для различных процессов для повышения общей производительности.\nПри разделении устройства между процессами может возникнуть необходимость в разграничении данных процессов друг от друга.Обычно она появляется при совместном использовании последовательных устройств, которые, в отличие от устройств прямого доступа, не адресуются. Для них организуется очередь заданий на вывод, каждое задание -порция данных, которую нельзя разрывать."
            answer[23] =
                "Разнообразие устройств ввода-вывода делает актуальной функцию ОС по созданию экранирующего\nлогического интерфейса между периферийными устройствами и приложениями.\nДля этого используется файловая модель периферийных устройств, когда любое устройство выглядит для прикладного программиста последовательным набором байт, с которым можно работать с помощью унифицированных системных вызовов, задавая имя файла-устройства и\nсмещение от начала последовательности байт.\nМодель файла-устройства простая и унифицированная для устройств любого типа, но во многих случаях для программирования операций ввода-вывода некоторого устройства она является слишком бедной. Поэтому она часто используется в качестве базиса, над которым подсистема ввода-вывода строит более содержательную модель устройства конкретного типа.\nДинамическая загрузка и выгрузка драйверов\nТак как набор потенциально поддерживаемых данных ОС периферийных устройств всегда шире набора устройств, которыми ОС должна управлять при установке на конкретной машине, ценным свойством ОС является возможность динамически загружать в оперативную память требуемый драйвер (без остановки ОС) и выгружать его, если надобность в драйвере отпала. Такое свойство\nОС может существенно сэкономить системную область памяти.\nАльтернативой динамической загрузке драйверов при изменении текущей конфигурации внешних устройств компьютера является повторная компиляция кода ядра с требуемым набором драйверов, что создает между всеми компонентами ядра статические связи вместо динамических. При статистических вызовах между ядром и драйверами структура ОС упрощается, но этот подход требует наличия исходных кодов модулей ОС, доступность которых скорее является исключением. В этом варианте работающую версию ОС надо остановить и заменить новой, что не всегда допустимо в некоторых применениях.\nПоэтому поддержка динамической загрузки драйверов является практически обязательным требованием для современных универсальных ОС."
            answer[24] =
                "Для разработки драйверов необходимо открытое API. В первую очередь – модуль ядра, и интерфейс драйвер-ядро должен быть стандартизирован в любом случае. Для этого во всех ОС существует несколько различных интерфейсов, чаще всего используются два: DKI и DDI, предоставляя интерфейс для блочных и символьных устройств. У драйверов существуют следующие функции:\n1. Обработка запросов записи и чтения от процессов;\n2. Проверка входных параметров и обработка ошибок;\n3. Инициализация устройства - помимо физического запуска устройства, драйвер должен отдать в ядро ОС определенную структуру, в противном случае устройство не считается запущенным;\n4. Управление энергопотреблением;\n5. Регистрация событий;\n6. Выдача команд (для устройства);\n7. Проверка правильности завершения – выполняется с помощью определенной команды в ядро ОС;\n8. Передача запрошенных данных;\n9. Обработка нового запроса при незавершенном предыдущем."
            answer[25] =
                "Функции подсистемы ввода/вывода: \n1. Организация параллельной работы устройств ввода/вывода и процессора; \n2. Согласование скоростей обмена и кэширования данных; \n3. Разделение устройств и данных между процессами;\n 4. Обеспечение удобного логического интерфейса между устройствами и остальной частью системы; \n5. Поддержка широкого спектра драйверов;\n6. Динамическая загрузка и выгрузка драйверов; \n7. Поддержка различных файловых систем; \n8. Поддержка синхронных и ассинхронных операций ввода/вывода. \nОперация ввода-вывода может выполняться по отношению к программному модулю, запросившему операцию, в синхронном или асинхронном режимах. Синхронный означает, что программный модуль приостанавливает свою работу, пока операция ввода-вывода не будет завершена. В асинхронном -программный модуль продолжает выполняться в мультипрограммном режиме одновременно с операцией ввода-вывода. \nОтличие в том, что операция ввода-вывода может быть инициирована не только пользовательским процессом – в этом случае операция выполняется в рамках системного вызова, – но и кодом ядра, например, кодом подсистемы виртуальной памяти для считывания отсутствующей страницы. \nСистемы вызовы ввода-вывода чаще оформляются как синхронные процедуры в связи с тем, что такие операции длятся долго и пользовательскому процессу или потоку все равно придется ждать получения результатов потоков операции, для того чтобы продолжить свою работу. \nВнутренние вызовы операций ввода-вывода из модулей ядра обычно выполняются в виде асинхронных процедур, так как кодам ядра нужна свобода в выборе дальнейшего поведения после запроса ввода-вывода."
            answer[26] =
                "ПО подсистемы ввода-вывода делится на горизонтальные и вертикальные слои. В каждой вертикальной подсистеме – несколько слоев модулей. Нижний слой образует аппаратные драйверы, управляющие аппаратурой внешних устройств, осуществляя обмен байтами и блоками байтов. Этот слой ПО не имеет дела с вопросами логической организации данных, например, с файлами или сложными графическими объектами. Функции вышележащих слоев в значительной степени зависят от типа вертикальной подсистемы. "
            answer[27] =
                "«Драйвер» – программный модуль, который:\n• входит в состав ядра ОС, работая в привилегированном режиме;\n• непосредственно управляет внешним устройством, взаимодействуя с его контроллером с помощью команд ввода-вывода компьютера; \n• обрабатывает прерывания от контроллера устройства;\n• предоставляет прикладному программисту удобный логический интерфейс работы с устройством, экранируя от него низкоуровневые детали управления устройством и организации его данных;\n• взаимодействует с другими модулями ядра ОС с помощью строго оговоренного интерфейса, описывающего формат передаваемых данных, структуру буферов, способы включения драйвера в состав ОС, способы вызова драйвера, набор общих процедур подсистемы ввода вывода, которыми драйвер может пользоваться и т.п. Традиционные драйверы (аппаратные, низкоуровневые или драйверы устройств) освобождаются\nот высокоуровневых функций и занимаются только низкоуровневыми операциями. При таком подходе повышается гибкость и расширяемость функции по управлению устройством.\nВысокоуровневые драйверы оформляются по тем же правилам и придерживаются тех же внутренних интерфейсов. Они не вызываются по прерываниям, так как взаимодействуют с устройством через посредничество аппаратных драйверов.\nАппаратные драйверы после запуска операции ввода-вывода должны своевременно реагировать на завершение контроллером заданного действия путем взаимодействия с системой прерывания.\nДрайверы более высоких уровней вызываются не по прерываниям, а по инициативе аппаратных драйверов или драйверов вышележащего уровня. "
            answer[28] =
                "Существуют следующие требования для хранения данных на устройствах:\n1. Устройства должны позволят хранить данные в больших объемах;\n2. Информация должна длительно и надежно сохраняться после прекращения работы процесса;\n3. Несколько процессов должны иметь возможность получения одновременного доступа к информации.\nПри рассмотрении отдельных файлов и их совокупностей используются следующие понятия:\n1. Поле – основной элемент данных; 2. Запись – набор связанных между собой полей, которые могут быть обработаны как единое целое некоторой прикладной программы. Запись необходимо рассматривать как экземпляр класса;\n3. Файл – совокупность однородных записей. Центральным объектом файловой системы является файл. На текущий момент обязательно использование StreamWrite и StreamRead для записи и чтения файлов. При работе с большими объемами данных необходимо преобразовывать всё в байты, а после этого при необходимости разбивать на массив исходную последовательность и работать с этим массивом в несколько потоков, используя делегаты для взаимодействия между этими потоками;\n4. База данных – набор связанных между собой данных, представленных совокупностью файлов одного или нескольких типов. При записи большого количества данных (от 1000 INSERT’ов одновременно) или при записи в несколько таблиц необходимо пользоваться транзакциями, чтобы в случае проблемы все остаточные данные удалялись без вашего участия.\nФайловая система – это часть ОС, которая включает в себя:\n1. Совокупность всех файлов на носителе информации;\n2. Наборы структур данных, используемых для управления файлами. (Дескрипторы файлов, таблица распределения свободного и занятого пространства и хранение файлов (каталоги));\n3. Комплекс системных программных средств, реализующих различные операции над файлами (Создание, уничтожение, чтение, запись итд).\nЗадачи файловой системы в мультипрограммных многопользовательских ОС:\n1. Соответствие требованиям управления данными и требованиям со стороны пользователей;\n2. Гарантирование корректности данных. Проверка четности и контрольная сумма;\n3. Оптимизация производительности, как с точки зрения системы, так и с точки зрения пользователя. Со стороны пользователя – время отклика, со стороны системы – пропускная способность;\n4. Поддержка ввода/вывода для различных типов устройств хранения информации;\n5. Минимизация или полное исключение потерь и повреждений данных;\n6. Защита от несанкционированного доступа. В большинстве файлов систем устроена с помощью ролей доступа;\n7. Обеспечение поддержки совместного использования;\n8. Обеспечение стандартизированного набора подпрограмм интерфейса ввода/вывода. В данном пункте понимается, как единообразие открытия и чтения, так и единообразия записи и изменения.\nМинимальным набором требований системы со стороны пользователя является:\n1. Создание, удаление, чтение и изменение файла;\n2. Контролируемый доступ к файлам;\n3. Управление доступом к своим файлам;\n4. Реструктурирование файлов в соответствии с решаемой задачей;\n5. Перемещение данных между файлами;\n6. Резервирование и восстановление файлов в случае повреждения;\n7. Доступ к файлам по символьным именам. "
            answer[29] =
                "На нижнем уровне драйверы устройств непосредственно связаны с периферийными устройствами или их котроллерами либо каналами. Драйвер устройства отвечает за начальные операции ввода вывода устройства и за обработку завершения запроса ввода-вывода.\nСледующий уровень называется базовой файловой системой, или уровнем физического ввода вывода. Это первичный интерфейс с окружением (периферией) компьютерной системы. Он\nоперирует блоками данных, которыми обменивается с дисками, магнитной лентой и другими устройствами.\nДиспетчер базового ввода-вывода отвечает за начало и завершение файлового ввода-вывода.\nДиспетчер осуществляет выбор устройства, на котором будет выполняться операция файлового ввода-вывода, планирование обращения к устройству (дискам, лентам), назначение буферов ввода вывода и распределение внешней памяти.\nЛогический ввод-вывод предоставляет приложениям и пользователям доступ к записям. Он обеспечивает возможности общего назначения по вводу-выводу записей и поддерживает информацию о файлах, обеспечивает стандартный интерфейс между приложениями и файловыми системами и устройствами, содержащими данные. Различные метод"
            answer[30] =
                "Использование собственных расширений файлов усложняет работу файловой системы в части индексации и поиска, так как файловая система пытается выполнить 2 действия:\n• Применить известные ей форматы для индексирования;\n• Проиндексировать как текст.\nУ файла существуют следующие атрибуты:\n1. Тип файла (обычный, каталог, специальный);\n2. Владелец файла (появляется в момент использования);\n3. Создатель файла;\n4. Дата создания;\n5. Дата изменения;\n6. Пароль;\n7. Текущий размер файла;\n8. Максимальный размер;\n9. Флаг “только чтение” – на 60% может повысить защищенность важных файлов;\n10. Флаг “скрытый”;\n11. Флаг “системный” - файл запрещено переименовывать и менять расширение, но этот процесс не всегда контролируется файловой системой;\n12. Флаг “архивный” – требуется или не требуется архивация;\n13. Флаг “ASCII /двоичный”. Двоичные данные – это тип BASE64;\n14. Флаг произвольного доступа – либо только последовательный, либо только произвольный доступ;\n15. Флаг “временный” – после окончания процесса данный файл должен быть уничтожен;\n16. Позиция ключа;\n17. Длина ключа;\n18. Средняя длина имени файла – 8 байт.\nИзвестно пять фундаментальных способов организации файлов:\n• смешанный файл;\n• последовательный файл;\n• индексно-последовательный файл;\n• индексируемый файл;\n• файл прямого доступа."
            answer[31] =
                "Файловый каталог - связующее звено между системой управления файлами и набором. Он содержит информацию о файлах, включая атрибуты, местоположение, принадлежность. Каталоговые системы имеют иерархическую структуру. Граф, описывающий иерархию каталогов, может быть деревом или сетью. Каталоги образуют дерево, если файлу разрешено входить только в один каталог, и сеть, если файл может входить в несколько каталогов. \nНапример, в Ms-Dos и Windows каталоги образуют древовидную структуру, а в UNIX – сетевую. \nОдноуровневые каталоговые системы. \nВ этой системе все файлы содержатся в одном каталоге. Однокаталоговая система, содержащая четыре файла, файлов А - два, но разных владельцев. \nПреимущества системы: \n1. Простота; \n2. Возможность быстро найти файл, не надо лазить по каталогам. \nНедостатки системы: \n1. Различные пользователи могут создать файлы с одинаковыми именами. \nДвухуровневые каталоговые системы.\nДля каждого пользователя создается свой собственный каталог. Пользователь, при входе в систему, попадает в свой каталог и работает только с ним. Это делает проблематичным использование системных файлов. \nПроблема решается созданием системного каталога с общим доступом. Если у одного пользователя много файлов, то у него тоже может возникнуть необходимость в файлах с одинаковыми именами. \nИерархические каталоговые системы. \nКаждый пользователь может создавать столько каталогов, сколько ему нужно. Почти все современные универсальные ОС, организованы таким образом. Специализированным ОС это может быть не нужным."
            answer[32] =
                "Принципы размещения файлов, каталогов и системной информации на реальном устройстве описываются физической организацией файловой системы. \nЖесткие и гибкие магнитные диски - основное устройство для хранения файлов. Жесткие диски состоят из одной или нескольких стеклянных или металлических пластин, каждая из которых покрыта с одной стороны или двух сторон магнитным материалом. \nНа каждой стороне каждой пластины размечены тонкие концентрические кольца – дорожки, на которых хранятся данные. Нумерация дорожек начинается с 0 от внешнего края к центру диска. Когда диск вращается, магнитные головки, имеющиеся над (под) каждой поверхностью диска, считывают или записывают двоичные данные на магнитные дорожки. Головки могут позиционировать над каждой дорожкой, если на одну поверхность диска в устройстве имеется одна головка. Некоторые диски имеют по отдельной головке на каждую дорожку, тогда позиционирование головок не требуется, что повышает быстродействие диска. \nСовокупность дорожек одного радиуса на всех поверхностях пластин пакета называется цилиндром. Каждая дорожка разбивается на фрагменты, называемые секторами или блоками, так что все дорожки имеют равное число секторов, в которые можно максимально записать одно и то же число байт. Сектор имеет фиксированный для данной системы размер, выражающийся степенью двойки (чаще всего 512 байт). \nСектор – наименьшая адресуемая единица обмена данными диска с оперативной памятью. Для того чтобы контроллер мог найти на диске нужный сектор, ему необходимо задать все составляющие адреса сектора: номер цилиндра, номер поверхности и номер сектора. Типичный запрос включает чтение (запись) нескольких секторов, содержащих наряду с требуемыми избыточные данные. \nОперационная система при работе с диском использует единицу дискового пространства, называемую кластером и содержащую несколько секторов в числе, кратном степени двойки. Это связано с тем, что применение более мелкой единицы дискового пространства – сектора – усложняет учет свободного и занятого пространства диска при современных больших емкостях дисков, исчисляющихся десятками и сотнями Гбайт. \nДорожки и секторы создаются в результате выполнения процедуры физического (низкоуровнего) форматирования диска, предшествующей использованию диска. Для определения границ блоков на диск записывается идентификационная информация. Низкоуровневый формат диска не зависит от типа ОС, которая с этим диском будет работать. \nРазметку диска под конкретный тип файловой системы выполняют процедуры высокоуровнего, или логического, форматирования. При высокоуровневом форматировании определяется размер кластера, записываются информация, необходимая для работы файловой системы, и загрузчик ОС – небольшая программа, которая начинает процесс инициализации операционной системы после включения питания. \nПрежде чем форматировать диск под определенную файловую систему, он может быть разбит на разделы. Раздел – это непрерывная часть физического диска, которую операционная система представляет пользователю как логическое устройство (логический диск или логический раздел). На каждом разделе может создаваться только одна файловая система."
            answer[33] =
                "Физическая организация выделяет способ размещения файлов на диске и учет соответствия блоков диска файлам. Основные критерии эффективности физической организации файлов:\n1. скорость доступа к данным;\n2. объем адресной информации файла;\n3. степень фрагментированности дискового пространства;\n4. максимально возможный размер файла.\nНаиболее часто используются следующие схемы размещения файлов:\n1. непрерывное размещение;\n2. сводный список блоков файла;\n3. сводный список индексов блоков файла;\n4. перечень номеров блоков файла в i-узлах.\nПростейший вариант физической организации – непрерывное размещение в наборе соседних кластеров. Достоинство – высокая скорость доступа и минимальный объем адресной информации.\nРазмер файла не ограничивается. Недостаток – фрагментация, возрастающая по мере удаления и записи файлов.\nВторой метод – представление файла в виде связного списка кластеров дисковой памяти. Первое слово каждого кластера используется как указатель на следующий кластер. Адресная информация минимальна. Доступ к файлу может медленный, тк для получения доступа к кластеру n ОС должна прочитать первые n-1 кластеры. Размер кластера уменьшается на несколько байтов, требуемых для хранения.\nОба недостатка предыдущей схемы можно устранить, храня указатели на следующие кластеры в отдельной таблице, загружаемой в память. Так образуется связный список индексов, указывающих на блоки файла."
            answer[34] =
                "FAT – Таблица Размещения Файлов (File Allocation Table), все данные о размещении файлов на диске находятся в этой таблице. \nДля обеспечения доступа приложений к файлам операционная система с файловой системой FAT использует следующие структуры: \n1. загрузочные секторы главного и дополнительных разделов; \n2. загрузочные секторы логических дисков (разделов); \n3. корневой каталог; \n4. область данных; \n5. цилиндр для выполнения диагностических операций чтения-записи. \nЗагрузочный сектор главного раздела (называемый главной загрузочной записью – Master Boot Record – MBR) является первым сектором на жестком диске и состоит из двух элементов: \n1. таблица главного раздела, содержащая список разделов (максимум четыре) и расположение загрузочных секторов соответствующих логических дисков; \n2. главный загрузочный код – небольшая программа, которая выполняется системой BIOS. Основная функция этого кода – передача управления в раздел, который обозначен как активный (загрузочный). \nЗагрузочный сектор раздела содержит: \n1. блок параметров диска, в котором содержится информация о разделе (размер, количество секторов, размер кластера, метка тома и др.); \n2. загрузочный код – программу, с которой начинается процесс загрузки операционной системы. \nФайловая система FAT поддерживает всего два типа файлов: обычный файл и каталог. Файловая система распределяет память только из области данных, причем использует в качестве минимальной единицы дискового пространства кластер. \nТаблица FAT (как основная копия, так и резервная) состоит из массива индексных указателей, количество которых равно количеству кластеров области данных. Между кластерами и индексными указателями имеется взаимно однозначное соответствие – нулевой указатель соответствует нулевому кластеру и т. д. \nИндексный указатель может принимать следующие значения, характеризующие состояние связанного с ним кластера: \n• кластер свободен (не используется); \n• кластер используется файлом и не является последним кластером файла (в этом случае индексный указатель содержит номер следующего кластера файла); \n• последний кластер файла; \n• дефектный кластер; \n• резервный кластер."
            answer[35] =
                "Файловая система ОС должна предоставлять пользователям набор операций для работы с файлами, оформленный в виде системных вызовов. В различных ОС имеются различные наборы файловых операций.\nНаиболее часто встречающиеся системные вызовы для работы с файлами:\n1. Create (создание). Файл создается без данных. Этот системный вызов объявляет о появлении нового файла и позволяет установить некоторые его атрибуты;\n2. Delete (удаление). Ненужный файл удаляется, чтобы освободить пространство на диске;\n3. Open (открытие). До использования файла его нужно открыть. Данный вызов позволяет прочитать атрибуты файла и список дисковых адресов для быстрого доступа к содержимому файла;\n4. Close (закрытие). После завершения операций с файлом его атрибуты и дисковые адреса не нужны. Файл следует закрыть, чтобы освободить пространство во внутренней таблице;\n5. Read (чтение). Файл читается с текущей позиции. Процесс, работающий с файлом, должен указать (открыть) буфер и количество читаемых данных;\n6. Write (запись). Данные записываются в файл в текущую позицию. Если она находится в конце файла, его размер автоматически увеличивается. В противном случае запись производится поверх существующих данных;\n7. Append (добавление). Это усеченная форма предыдущего вызова. Данные добавляются в конец файла;\n8. Seek (поиск). Данный системный вызов устанавливает файловый указатель в определенную позицию;\n9. Get attributes (получение атрибутов). Процессам для работы с файлами бывает необходимо получить их атрибуты;\n10. Set attributes (установка атрибутов). Этот вызов позволяет установить необходимые атрибуты файлу после его создания;\n11. Rename (переименование). Этот системный вызов позволяет изменить имя файла. Однако такое действие можно выполнить копированием файла. Поэтому данный системный вызов не является необходимым;\n12. Execute (выполнить). Используя этот системный вызов, файл можно запустить на выполнение."
            answer[36] =
                "Пользователи - субъекты доступа, разделяемые ресурсы – объекты. Пользователь осуществляет доступ к объектам c помощью прикладных процессов, запускаемых от его имени.\nДля каждого типа объекта существует набор операций, которые можно с ним выполнять. Система контроля доступа ОС должна предоставлять средства для задания прав пользователей по отношению к объектам дифференцированно по операциям.\nВ качестве субъектов доступа могут выступать как отдельные пользователи, так и группы пользователей. Объединение пользователей с одинаковыми правами в группу и задания прав доступа в целом для группы - один из основных приемов администрирования в больших системах.\nУ каждого объекта доступа существует владелец. Он может выполнить с ним любые допустимые для данного объекта операции. Во многих ОС существует особый пользователь – администратор «superuser», который имеет все права по отношению к объектам системы, не обязательно являясь их владельцем. Эти права необходимы администратору для управления политикой доступа.\nРазличают два основных подхода к определению прав доступа:\n• Избирательный доступ – ситуация, когда владелец объекта определяет допустимые операции с объектом. Называется также произвольным доступом, так как позволяет администратору и владельцам объекта определить права доступа по их желанию.\nАдминистратор по умолчанию наделен всеми правами.\n• Мандатный доступ – подход к определению прав доступа, при котором система (администратор) наделяет пользователя или группу определенными правами по отношению к каждому разделяемому ресурсу. Группы пользователей образуют строгую иерархию, каждая группа пользуется всеми правами группы более низкого уровня иерархии.\nМандатные системы доступа более надежные, но менее гибкие, применяются в системах с повышенными требованиями к защите информации.\nКаждый пользователь (группа) имеет символьное имя и уникальный числовой идентификатор. При выполнении процедуры логического входа в систему пользователь сообщает свое символьное имяили пароль. Все идентификационные данные и сведения о вхождении пользователя в группы хранятся в специальном файле или базе данных.\nВход пользователя в систему порождает процесс – оболочку, который поддерживает диалог с пользователем и запускает для него другие процессы. Любой порождаемый процесс наследует идентификаторы пользователя и групп от процесса родителя.\nВ самом общем случае права доступа могут быть описаны матрицей прав доступа, в которой столбцы соответствуют всем файлам системы, а строки – всем пользователям. На пересечении строк и столбцов указываются разрешенные операции. Матрица хранится по частям, т.е. для каждого файла и каталога создается список управления доступом, где описываются права на выполнение операций пользователей и групп пользователей по отношению к этому файлу или каталогу. Список управления доступом - часть характеристик файла или каталога, хранится на диске в соответствующей области.\nПроверки прав доступа для объектов любого типа выполняются централизованно с помощью монитора безопасности, работающего в привилегированном режиме.\nДля системы безопасности Windows характерно большое количество различных встроенных субъектов доступа – отдельных пользователей и групп. Они наделены определенными правами, что облегчает работу администратора по созданию эффективной системы разграничения доступа. Во первых, за счет того, что нового пользователя можно внести в какую-то группу. Во-вторых, можно добавлять\\изымать права встроенных групп, создавать новые группы с уникальным набором прав. "
            answer[37] =
                "• Планирование заданий - процедура выбора очередного задания для загрузки в машину, т. е. для порождения соответствующего процесса;\n• Планирование использования процессора - впервые возникает в мультипрограммных вычислительных системах, где в состоянии готовность могут одновременно находиться несколько процессов. Именно для процедуры выбора из них одного процесса, который получит процессор в свое распоряжение, т. е. будет переведен в состояние исполнение.\nПланирование  заданий используется в качестве  долгосрочного планирования процессов.\nОтвечает з а порождение новых процессов в системе, определяя е е  степень мультипрограммирования, т. е. количество процессов, одновременно находящихся в ней.\nЕсли  степень мультипрограммирования  системы поддерживается постоянной, т. е. среднее количество процессов в компьютере не меняется, то новые процессы могут появляться только после завершения ранее загруженных. Поэтому  долгосрочное планирование  осуществляется достаточно\nредко, между появлением новых процессов могут проходить минуты и даже десятки минут.\nПланирование  использования процессора применяется в качестве  краткосрочного планирования процессов. Оно проводится, к примеру, при обращении исполняющегося процесса к устройствам ввода-вывода или просто по завершении определенного интервала времени.\nПоэтому  краткосрочное планирование  осуществляется, как правило, не реже одного раза в 100 миллисекунд. Выбор нового процесса для исполнения оказывает влияние на функционирование системы до наступления очередного аналогичного события, т. е. в течение короткого промежутка времени, чем и обусловлено название этого уровня планирования – краткосрочное.\nПромежуточный уровень планирования процессов – среднесрочный – временное удаление какого-либо частично выполненного процесса из оперативной памяти на диск – swapping."
            answer[38] =
                "Для каждого уровня планирования можно предложить несколько различных алгоритмов. Выбор алгоритма планирования определяется классов задач и целями, которые необходимо достичь. К числу целей можно отнести: \n1. Справедливость – гарантирование каждому заданию или процессу части времени ЦП; \n2. Эффективность; \n3. Сокращение полного времени выполнения – сокращение времени получения результата между запуском и завершением; \n4. Сокращение времени ожидания – время между процессами; \n5. Сокращение времени отклика. \nВ качество основного параметра, который рассматривается разработчиками ОС, рассматривается время загрузки ЦП задачами пользователя. Критерии, которые показывают, что ОС работает корректно, отвечают требованиям 40-90% процессорного времени для пользовательских задач. \nНезависимо от поставленных целей  планирования  желательно, чтобы алгоритмы обладали следующими свойствами: \n• Были предсказуемыми; \n• Были связаны с минимальными накладными расходами; \n• Равномерно загружали ресурсы вычислительной системы, отдавая предпочтение тем процессам, которые будут занимать малоиспользуемые ресурсы; \n• Обладали масштабируемостью, т.е. не сразу теряли работоспособность при увеличении нагрузки."
            answer[39] =
                "Все параметры планирования можно разделить на 2 большие группы:\n1. Статистические\na. Каким пользователем был запущен процесс. С точки зрения запуска пользователем ОС всегда отдает предпочтение пользовательским задачам, далее следуют задачи локальной системы, далее – локальная служба, далее – сетевая служба.\nb. Приоритет выполнения.\nc. Сколько процессорного времени запрошено для решения задач. Оценка времени выполнения по каким-либо критериям.\nd. Какого соотношение процессорного времени, необходимого для осуществления операции ввода/вывода. В первую очередь зависит от времени прерывания для самой операции ввода/вывода, а также от устройств, который занимаются вводов/выводом.\ne. Какие ресурсы вычислительной системы. ОП, ЦП.\n2. Динамические\na. Количество времени с момента выгрузки процесса на диск или загрузки в оперативную память. \nb. Сколько оперативной памяти занимает процесс.\nc. Сколько процессорного времени уже предоставлено процессу.\nCPU burst – промежуток времени непрерывного использования процессора, а промежуток времени непрерывного использования операции ввода/вывода называется I/O burst. Они так же относятся к динамическому планированию.\nДолгосрочное и среднесрочное планирование используют как динамические, так и статические параметры планирования, но больше ориентируется на статическое планирование.\nПланирование ввода/вывода и краткосрочное планирование не используют статику, а используют только динамические параметры. "
            answer[40] =
                "Вытесняющие алгоритмы реализованы в ОС разделения времени и реального времени. В ОС реального времени существуют параметры, указывающие на количество возможных вытеснений из очереди на выполнение, после этого поток будет выполнен в любом случае. В этом режиме планирования процесс может быть приостановлен в любой момент исполнения. ОС устанавливает специальный таймер для генерации сигнала прерывания по истечении некоторого интервала времени – кванта. После прерывания процессор передается в распоряжение следующего процесса. Временные прерывания помогают гарантировать приемлемое время отклика процессов для пользователей, работающих в диалоговом режиме, и предотвращают «зависание» компьютерной системы из-за зацикливания какой-либо программы. \nНевытесняющее планирование используется только в ОС пакетной обработки. При таком режиме планирования процесс занимает столько процессорного времени, сколько ему необходимо. При этом переключение процессов возникает только при желании самого исполняющегося процесса передать управление (для ожидания завершения операции ввода-вывода или по окончании работы). Этот метод планирования относительно просто реализуем и достаточно эффективен, так как позволяет выделить большую часть процессорного времени для работы самих процессов и до минимума сократить затраты на переключение контекста. При невытесняющем планировании возникает проблема возможности полного захвата процессора одним процессом, который вследствие каких-либо причин (например, из-за ошибки в программе) зацикливается и не может передать управление другому процессу. В такой ситуации спасает только перезагрузка всей вычислительной системы."
            answer[41] =
                "FCFS – First Come First Served – простейший алгоритм планирования. Его основным преимуществом является простота реализации. Для этого полагается, что вся деятельность процессов ограничивается только CPU burst, процессы не совершают операции ввода/вывода, а времяпереключения между процессами настолько мало, что им можно пренебречь. Такой алгоритм выбора процесса осуществляет невытесняющее планирование. \nСреднее время ожидания и среднее полное время выполнения для этого алгоритма существенно зависят от порядка расположения процессов в очереди. Если у нас есть процесс с длительным CPU burst , то короткие процессы, перешедшие в состояние готовность после длительного процесса, будут очень долго ждать начала выполнения. Поэтому алгоритм FCFS практически неприменим для систем разделения времени – слишком большим получается среднее время отклика в интерактивных процессах."
            answer[42] =
                "Robin Round – модификация алгоритма FCFS. Это тот же алгоритм, но реализованный в режиме вытесняющего планирования (последовательно). Планировщик выбирает для очередного исполнения процесс, расположенный в начале очереди, и устанавливает таймер для генерации прерывания по истечении определенного времени (кванта). По истечению возможны 2 варианта: \na. Время непрерывного использование меньше или равно продолжительности кванта, тогда процесс по своей воле освобождает ЦП и по истечению кванта начинается работа нового процесса; \nb. Продолжительность остатка CPU burst больше, чем квант времени, тогда процесс прерывается и помещается в конец очереди. \nВ случае, если изначально известно, какое количество времени будет занимать тот или иной процесс, то алгоритм FCFS, выстроенный в порядке возрастания времени выполнения, будет более эффективным, чем Robin Round, в противном случае используется Robin Round."
            answer[43] =
                "SJF – алгоритм краткосрочного планирования, может быть как вытесняющим, так и не вытесняющим. При невытесняющем планировании процессор предоставляется выбранному процессу на всё необходимое время. При вытесняющим учитывается появление новых процессов из числа вновь созданных или разблокированных и если CPU burst нового процесса меньше, чем CPU burst у исполняющегося, то исполняющийся вытесняется. \nПри каждом появлении в очереди процесса планирование пересматривается заново. \nОсновную сложность в реализации таких алгоритмов представляет собой невозможность точного знания CPU Burst для всех процессов. Для этого при краткосрочном планировании делается прогноз длительности следующего CPU Burst исходя из статистики работы процесса ранее. Чаще всего выбирают половину от среднего времени выполнения данного процесса. Такой способ удобен для быстрой оценки времени работы процесса."
            answer[44] =
                "ри интерактивной работе  N  пользователей в вычислительной системе можно применить алгоритм планирования, который гарантирует, что каждый из пользователей будет иметь в своем распоряжении ~1/N часть процессорного времени. Пронумеруем всех пользователей от 1 до N. Для каждого пользователя с номером  i  введем две величины: Ti – время нахождения пользователя в системе или, другими словами, длительность сеанса его общения с машиной и  – суммарное процессорное время уже выделенное всем его процессам в течение сеанса. Справедливым для пользователя было бы получение Ti/N процессорного времени. Если , то i -й пользователь несправедливо обделен процессорным временем. Если же , то система явно благоволит к пользователю с номером i. Вычислим для процессов каждого пользователя значение коэффициента справедливости и будем предоставлять очередной  квант времени  готовому процессу с наименьшей величиной этого отношения . Предложенный алгоритм называют алгоритмом  гарантированного планирования. К недостаткам этого алгоритма можно отнести невозможность предугадать поведение пользователей. Если некоторый пользователь отправится на пару часов пообедать и поспать, не прерывая сеанса работы, то по возвращении его процессы будут получать неоправданно много процессорного времени."
            answer[45] =
                "При приоритетном планировании каждому процессу присваивается определенное числовое значение – приоритет, в соответствии с которым ему выделяется процессор. Процессы с одинаковыми приоритетами планируются в порядке FCFS. Для алгоритма SJF в качестветакого приоритета выступает оценка продолжительности следующего CPU burst. Чем меньше ее значени, тем более высокий приоритет имеет процесс. Для алгоритма гарантированного планирования приоритетом служит вычисленный коэффициент справедливости. Чем он меньше, тем больше у процесса приоритет (наименьший приоритет – более высокий). \nПланирование с использованием приоритетов может быть как вытесняющим, так и невытесняющим. При вытесняющем планировании процесс с более высоким приоритетом, появившийся в очереди готовых процессов, вытесняет исполняющийся процесс с более низким приоритетом. В случае невытесняющего планирования он просто становится в начало очереди готовых процессов."
            answer[46] =
                "Для систем, в которых процессы могут быть рассортированы по разным группам, был разработан класс планирования многоуровневых очередей. Для каждой группы процессов создается собственная очередь и этим очередям приписываются фиксированные приоритеты и приоритет очереди рассматривается в качестве первого параметра планирования. Для очереди применяется алгоритм либо FCFS (без взаимодействия с пользователем), либо Robin Round, если процессы интерактивные. \nДальнейшим развитием алгоритма многоуровневых очередей является добавление к нему механизма обратной связи. Здесь процесс не постоянно приписан к определенной очереди, а может мигрировать из одной очереди в другую в зависимости от своего поведения."
            answer[47] =
                "Различные процессы могут исполняться псевдопараллельно на одной или параллельно на разных вычислительных системах, взаимодействуя между собой. Какие существуют причины для их кооперации? \n• Повышение скорости работы. Пока один процесс ожидает наступления некоторого события, другие могут заниматься полезной работой, направленной на решение общей задачи. В многопроцессорных вычислительных системах программа разбивается на отдельные кусочки, каждый из которых будет исполняться на своем процессоре. \n• Совместное использование данных. Различные процессы могут, к примеру, работать с одной и той же динамической базой данных или с разделяемым файлом, совместно изменяя их содержимое. \n• Модульная конструкция какой-либо системы. Типичным примером может служить микроядерный способ построения ОС, когда различные ее части представляют собой отдельные процессы, взаимодействующие путем передачи сообщений через микроядро. \n• Удобство работы пользователя, желающего, например, редактировать и отлаживать программу одновременно. В этой ситуации процессы редактора и отладчика должны уметь взаимодействовать друг с другом. \nПроцессы не могут взаимодействовать, не обмениваясь информацией. Это приводит к изменению их поведения в зависимости от полученной информации. Если деятельность процессов остается неизменной при любой принятой ими информации, значит, они в «общении» не нуждаются. Процессы, которые влияют на поведение друг друга путем обмена информацией, принято называть кооперативными или взаимодействующими процессами, в отличие от независимых процессов, не оказывающих друг на друга никакого воздействия.\nРазличные процессы в вычислительной системе изначально представляют собой обособленные сущности. Работа одного процесса не должна приводить к нарушению работы другого процесса. Для этого разделены их адресные пространства и системные ресурсы, и для обеспечения корректного взаимодействия процессов требуются специальные средства и действия операционной системы. Нельзя просто поместить значение, вычисленное в одном процессе, в область памяти, соответствующую переменной в другом процессе, не предприняв каких-либо дополнительных усилий."
            answer[48] =
                "Процессы могут взаимодействовать друг с другом, только обмениваясь информацией. По  объему передаваемой информации и степени возможного воздействия на поведение другого процесса все средства такого обмена можно разделить на три категории: \n• Сигнальные - передается минимальное количество информации – один бит, «да» или «нет»; \n• Канальные – «общение» процессов происходит через линии связи, предоставленные операционной системой; \n• Разделяемая память - два или более процессов могут совместно использовать некоторую область адресного пространства. Созданием разделяемой памяти занимается ОС. Различают два способа адресации: прямую и непрямую.\nВ случае прямой адресации взаимодействующие процессы непосредственно общаются друг с другом, при каждой операции обмена данными явно указывая имя или номер процесса, которому информация предназначена или от которого она должна быть получена. Если и процесс, от которого данные исходят, и процесс, принимающий данные, указывают имена своих партнеров по взаимодействию, то такая схема адресации называется симметричной прямой адресацией. Ни один другой процесс не может вмешаться в процедуру симметричного прямого общения двух процессов, перехватить посланные или подменить ожидаемые данные. Если только один из взаимодействующих процессов указывает имя своего партнера по кооперации, а второй процесс в качестве возможного партнера рассматривает любой процесс в системе, такая схема адресации называется асимметричной прямой адресацией.\nПри непрямой адресации данные помещаются передающим процессом в некоторый промежуточный объект для хранения данных, имеющий свой адрес, откуда они могут быть затем изъяты каким-либо другим процессом.\nПри использовании  прямой адресации  связь между процессами в классической ОС устанавливается автоматически, без дополнительных  инициализирующих действий. Для использования средства связи нужно знать, как идентифицируются процессы, участвующие в обмене данными.\nПри использовании  непрямой адресации  инициализация средства связи может и не требоваться. Информация, которой должен обладать процесс для взаимодействия с другими процессами, – некий идентификатор промежуточного объекта для хранения данных, если он не является единственным и неповторимым в вычислительной системе для всех процессов."
            answer[49] =
                "Новая абстракция внутри понятия «процесс» – нить исполнения. Нити процесса разделяют его программный код, глобальные переменные и системные ресурсы, но каждая нить имеет собственный программный счетчик, свое содержимое регистров и свой стек. Теперь процесс представляется как совокупность взаимодействующих нитей и выделенных ему ресурсов. Процесс, содержащий всего одну нить исполнения, идентичен процессу в том смысле, который мы употребляли ранее (традиционный процесс). Нити называют облегченными процессами или мини процессами, так как во многих отношениях они подобны традиционным процессам. Они могут порождать нити-потомки, но только внутри своего процесса, и переходить из одного состояния в другое.\nСостояния нитей аналогичны состояниям традиционных процессов. Из состояния рождение процесс приходит содержащим всего одну нить исполнения. Другие нити процесса будут являться потомками этой нити-прародительницы. Процесс находится в состоянии готовность, если хотя бы одна из его нитей находится в состоянии готовность и ни одна из нитей не находится в состоянии исполнение. Процесс находится в состоянии исполнение, если одна из его нитей находится в состоянии исполнение. Процесс будет находиться в состоянии ожидание, если все его нити находятся в состоянии ожидание. Процесс находится в состоянии закончил исполнение, если все его нити находятся в состоянии закончила исполнение.\nПока одна нить процесса заблокирована, другая нить того же процесса может выполняться. Нити разделяют процессор так же, как это делали традиционные процессы, в соответствии с рассмотренными алгоритмами планирования.\nПоскольку нити одного процесса разделяют существенно больше ресурсов, чем различные процессы, то операции создания новой нити и переключения контекста между нитями одного процесса занимают значительно меньше времени, чем аналогичные операции для процессов в целом.\nРазличают ОС, поддерживающие нити на уровне ядра и на уровне библиотек. Все сказанное выше справедливо для ОС, поддерживающих нити на уровне ядра. В них планирование использования процессора происходит в терминах нитей, а управление памятью и другими системными ресурсами остается в терминах процессов. В ОС, поддерживающих нити на уровне библиотек пользователей, и планирование процессора, и управление системными ресурсами осуществляются в терминах процессов. Распределение использования процессора по нитям в рамках выделенного процессу временного интервала осуществляется средствами библиотеки. В подобных системах блокирование одной нити приводит к блокированию всего процесса, ибо ядро операционной системы не имеет представления о существовании нитей. В таких вычислительных системах просто имитируется наличие нитей исполнения."
            answer[50] =
                "Неделимые операции(активности) могут иметь внутренние невидимые действия (атомарные операции), выполняемыми без прерывания.\nПри псевдопараллельном исполнении активности в режиме разделения времени могут расслоиться на неделимые операции с различным чередованием их неделимых операций − interleaving. Поэтому результат псевдопараллельного выполнения может отличаться от результата последовательного выполнения.\nНабор активностей детерминирован, если при псевдопараллельном исполнении для одного и того же набора входных данных он дает одинаковые выходные данные. Его можно безбоязненно выполнять в режиме разделения времени, недетерминированный − нежелательно. Недетерминированный набор программ имеет race condition.\nДля упорядоченного доступа к разделяемым данным (устранения race condition) каждому процессу нужно эксклюзивное право доступа к ним. При обращении к разделяемым ресурсам он исключает для других возможность одновременного общения с этими ресурсами, если это может привести к недетерминированному поведению набора процессов − взаимоисключение (mutual exclusion). Если очередность доступа к разделяемым ресурсам важна для получения правильных результатов, нужна взаимосинхронизация поведения программ.\nВзаимоисключение − 2 процесса, обратившись к ресурсу и не получив доступа, должны быть оба остановлены одновременно или остановлен только один.\nДля организации взаимоисключений критических участков существует 5 основных условий, которые должны выполняться для каждого процесса:\n1. Задача должна быть решена чисто программным способом на обычной машине, не имеющей специальных команд взаимоисключения;\n2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов, потому что этот процесс слишком непредсказуем;\n3. Если процесс, выполняется в своем критическом участке, то не должно существовать других процессов, которые выполняются в подобных критических участках;\n4. Процессы, которые находятся вне своих критических участков и не собираются в них входить, не должны препятствовать другим процессам входить в их критические участки;\n5. Не должно возникать бесконечного ожидания для входа в свой критический участок. ОС единообразно работает со всеми неразделяемыми ресурсами, а любое физическое устройство – это чаще всего неразделяемый ресурс."
            answer[51] =
                "Критическая секция – часть программы, исполнение которой может привести к возникновению race condition для определенного набора программ. Чтобы исключить этот эффект по отношению к некоторому ресурсу, необходимо организовать работу так, чтобы в каждый момент времени только один процесс мог находиться в своей критической секции, связанной с этим ресурсом. Иными словами, необходимо обеспечить реализацию взаимоисключения для критических секций программ.\nС практической точки зрения это означает, что по отношению к другим процессам, участвующим во взаимодействии, критическая секция начинает выполняться как атомарная операция.\nНа текущий момент API ОС формирует виртуальный ресурс, с помощью которого выстраивает очередь на реальный, уменьшая при этом время выполнения каждого процесса в своей критической секции. ОС для каждого процесса дает полный набор виртуальный ресурсов (неразделяемых). В таком случае критическая секция каждого процесса выполняется максимально быстро. Но даже это не исключает тупиковых ситуаций.\nДля организации взаимоисключений критических участков существует 5 основных условий, которые должны выполняться для каждого процесса:\n1. Задача должна быть решена чисто программным способом на обычной машине, не имеющей специальных команд взаимоисключения;\n2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов, потому что этот процесс слишком непредсказуем;\n3. Если процесс, выполняется в своем критическом участке, то не должно существовать других процессов, которые выполняются в подобных критических участках;\n4. Процессы, которые находятся вне своих критических участков и не собираются в них входить, не должны препятствовать другим процессам входить в их критические участки;\n5. Не должно возникать бесконечного ожидания для входа в свой критический участок."
            answer[52] =
                "Организация  взаимоисключения  для  критических участков не является достаточной для правильной и эффективной параллельной работы кооперативных процессов. Условия, которые должны выполняться для хорошего программного алгоритма организации взаимодействия процессов, имеющих критические участки, если они могут проходить их в произвольном порядке:\n1. Задача должна быть решена чисто программным способом на обычной машине, не имеющей специальных команд взаимоисключения;\n2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов, потому что этот процесс слишком непредсказуем;\n3. Если процесс, выполняется в своем критическом участке, то не должно существовать других процессов, которые выполняются в подобных критических участках;\n4. Процессы, которые находятся вне своих критических участков и не собираются в них входить, не должны препятствовать другим процессам входить в их критические участки;\n5. Не должно возникать бесконечного ожидания для входа в свой критический участок."
            answer[53] =
                "Запрет прерываний.\nНаиболее простым решением поставленной задачи является следующая организация пролога и эпилога: \nwhile (some condition) {\nзапретить все прерывания \ncritical section \nразрешить все прерывания \nremainder section\n } \nПоскольку выход процесса из состояния  исполнение  без его завершения осуществляется по прерыванию, внутри  критической секции  никто не может вмешаться в его работу. Но такое решение может иметь далеко идущие последствия, поскольку позволяет процессу пользователя разрешать и запрещать прерывания во всей вычислительной системе. Если пользователь случайно или по злому умыслу запретил прерывания в системе и зациклил или завершил свой процесс, без перезагрузки системы не обойтись. \nТем не менее запрет и разрешение прерываний часто применяются как пролог и эпилог к критическим секциям внутри самой ОС.\n Переменная-замок. \nВозьмем некоторую переменную, доступную всем процессам, с начальным значением равным  0. Процесс может войти в  критическую секцию  только тогда, когда значение этой переменной-замка равно  0, одновременно изменяя ее значение на  1 – закрывая замок. При выходе из  критической секции процесс сбрасывает ее значение в  0 – замок открывается (как в случае с покупкой хлеба студентами в разделе \" Критическая секция \"). \nshared int lock = 0;\n/* shared означает, что переменная является разделяемой */ \nwhile (some condition) { \nwhile(lock);\nlock = 1;\ncritical section\nlock = 0;\nremainder section\n} \nТакое решение не удовлетворяет условию взаимоисключения, так как действие while(lock); lock = 1; не является атомарным. Допустим, процесс P0 протестировал значение переменной lock и принял решение двигаться дальше. В этот момент, еще до присвоения переменной  lock  значения  1, планировщик передал управление процессу  P1. Он тоже изучает содержимое переменной  lock  и тоже принимает решение войти в критический участок. Мы получаем два процесса, одновременно выполняющих свои критические секции. \nСтрогое чередование.\nПопробуем решить задачу сначала для двух процессов. Очередной подход будет также использовать общую для них обоих переменную с начальным значением 0. Только теперь она будет играть не роль замка для  критического участка, а явно указывать, кто может следующим войти в него. Для i-го процесса это выглядит так: \nshared int turn = 0; \nwhile (some condition) { \nwhile(turn != i);\ncritical section turn = 1-i;\nremainder section\n } \nВзаимоисключение  гарантируется, процессы входят в  критическую секцию  строго по очереди: P0, P1, P0, P1, P0. Но наш алгоритм не удовлетворяет условию прогресса. Например, если значение  turn  равно  1, и процесс  P0  готов войти в  критический участок, он не может сделать этого, даже если процесс P1 находится в remainder section."
            answer[54] =
                "Флаги готовности\nЧтобы процессы знали о состоянии друг друга в текущий момент времемни, пусть два наших процесса имеют разделяемый массив флагов готовности входа процессов в критический участок \nshared int ready[2] = {0, 0}; \nКогда i-й процесс готов войти в критическую секцию, он присваивает элементу массива ready[i] значение равное 1. После выхода из критической секции он, естественно, сбрасывает это значение в 0. Процесс не входит в критическую секцию, если другой процесс уже готов к входу в критическую секцию или находится в ней. \nwhile (some condition) { \nready[i] = 1; \nwhile(ready[1-i]);\ncritical section \nready[i] = 0; \nremainder section\n}\nПолученный алгоритм обеспечивает взаимоисключение, позволяет процессу, готовому к входу в критический участок, войти в него сразу после завершения эпилога в другом процессе, но все равно нарушает условие прогресса. Пусть процессы практически одновременно подошли к выполнению пролога. После выполнения присваивания ready[0]=1 планировщик передал процессор от процесса 0 процессу 1, который также выполнил присваивание ready[1]=1. После этого оба процесса бесконечно долго ждут друг друга на входе в критическую секцию. Возникает ситуация, которую принято называть тупиковой (deadlock). \nАлгоритм Петерсона.\nПусть оба процесса имеют доступ к массиву флагов готовности и к переменной очередности.\nshared int ready[2] = {0, 0};\nshared int turn;\nwhile (some condition) {\n ready[i] = 1;\nturn =1-i;\nwhile(ready[1-i] && turn == 1-i);\ncritical section\n ready[i] = 0;\nremainder section \n}\nПри исполнении пролога критической секции процесс Pi заявляет о своей готовности выполнить критический участок и одновременно предлагает другому процессу приступить к его выполнению. Если оба процесса подошли к прологу практически одновременно, то они оба объявят о своей готовности и предложат выполняться друг другу. При этом одно из предложений всегда следует после другого. Тем самым работу в критическом участке продолжит процесс, которому было сделано последнее предложение. \nАлгоритм булочной.\n(Bakery algorithm) Алгоритм Петерсона дает нам решение задачи корректной организации взаимодействия двух процессов. Давайте рассмотрим теперь соответствующий алгоритм для n взаимодействующих процессов. Основная его идея выглядит так. Каждый вновь прибывающий клиент (он же процесс) получает талончик на обслуживание с номером. Клиент с наименьшим номером на талончике обслуживается следующим. К сожалению, из-за неатомарности операции вычисления следующего номера алгоритм булочной не гарантирует, что у всех процессов будут талончики с разными номерами. В случае равенства номеров на талончиках у двух или более клиентов первым обслуживается клиент с меньшим значением имени (имена можно сравнивать в лексикографическом порядке). Разделяемые структуры данных для алгоритма – это два массива \nshared enum {false, true} choosing[n];\nshared int number[n];\nИзначально элементы этих массивов инициируются значениями false и 0 соответственно. Введем следующие обозначения \n(a,b) < (c,d), если a < c\nили если a == c и b < d\nmax(a0, a1, ...., an) – это число k такое, что\nk >= ai для всех i = 0, ...,n\nСтруктура процесса Pi для алгоритма булочной приведена ниже\nwhile (some condition) {\nchoosing[i] = true;\nnumber[i] = max(number[0], ..., number[n-1]) + 1;\nchoosing[i] = false;\nfor(j = 0; j < n; j++){ \nwhile(choosing[j]); \nwhile(number[j] != 0 && (number[j],j) < (number[i],i));\n} \ncritical section \nnumber[i] = 0; \nremainder section \n}\nАппаратная поддержка взаимосключений. \nНаличие аппаратной поддержки взаимоисключений позволяет упростить алгоритмы и повысить их эффективность точно так же, как это происходит и в других областях программирования.\nМногие вычислительные системы помимо этого имеют специальные команды процессора, которые позволяют проверить и изменить значение машинного слова или поменять местами значения двух машинных слов в памяти, выполняя эти действия как атомарные операции."
            answer[55] =
                "О выполнении команды Test-and-Set , осуществляющей проверку значения логической переменной с одновременной установкой ее значения в 1, можно думать как о выполнении функции: \nint Test_and_Set (int *target){ \nint tmp = *target; \n*target = 1; \nreturn tmp; \n} \nС использованием этой атомарной команды мы можем модифицировать наш алгоритм для переменной-замка, так чтобы он обеспечивал взаимоисключения: \nshared int lock = 0; \nwhile (some condition) { \nwhile(Test_and_Set(&lock)); \ncritical section \nlock = 0; \nremainder section \n}\n Полученный алгоритм не удовлетворяет условию ограниченного ожидания для алгоритмов. Выполнение команды  Swap , обменивающей два значения, находящихся в памяти, можно проиллюстрировать следующей функцией: \nvoid Swap (int *a, int *b){\n int tmp = *a;\n*a = *b; \n*b = tmp; \n} \nПрименяя атомарную команду  Swap , мы можем реализовать предыдущий алгоритм, введя дополнительную логическую переменную key, локальную для каждого процесса: \nshared int lock = 0; \nint key;\nwhile (some condition) { \nkey = 1; \ndo Swap(&lock,&key); \nwhile (key); \ncritical section \nlock = 0; \nremainder section \n}"
            answer[56] =
                "Отображение виртуального адреса в физический осуществляется при помощи таблицы страниц. Для каждой виртуальной страницы запись в таблице страниц содержит номер соответствующего страничного кадра в оперативной памяти, а также атрибуты страницы для контроля обращений к памяти. \nКогда нужной страницы в памяти нет или операция обращения к памяти недопустима, при попытке выполнить подобное обращение к виртуальной странице возникает исключительная ситуация «страничное нарушение», приводящая к вызову специальной последовательности команд для обработки конкретного вида страничного нарушения. \nСтраничное нарушение может происходить в самых разных случаях: при отсутствии страницы в оперативной памяти, при попытке записи в страницу с атрибутом «только чтение» или при попытке чтения или записи страницы с атрибутом «только выполнение». В любом из них вызывается обработчик страничного нарушения, являющийся частью ОС. Ему передается причина возникновения исключительной ситуации и виртуальный адрес, обращение к которому вызвало нарушение. \nОбработка вариант страничного нарушения - обращения к отсутствующей странице во многом определяет производительность страничной системы. Когда программа обращается к виртуальной странице, отсутствующей в основной памяти, ОС должна выделить страницу основной памяти, переместить в нее копию виртуальной страницы из внешней памяти и модифицировать соответствующий элемент таблицы страниц. \nПовышение производительности вычислительной системы может быть достигнуто за счет уменьшения частоты страничных нарушений и увеличения скорости их обработки. Время эффективного доступа к отсутствующей в оперативной памяти странице складывается из: \n• обслуживания исключительной ситуации; \n• чтения (подкачки) страницы из вторичной памяти (иногда, при недостатке места в основной памяти, необходимо вытолкнуть одну из страниц из основной памяти во вторичную, то есть осуществить замещение страницы); \n• возобновления выполнения процесса, вызвавшего данный page fault. \nДля решения первой и третьей задач ОС выполняет до нескольких сот машинных инструкций в течение нескольких десятков микросекунд. Время подкачки страницы близко к нескольким десяткам миллисекунд. Уменьшение частоты page faults является одной из ключевых задач системы управления памятью. Ее решение обычно связано с правильным выбором алгоритма замещения страниц."
            answer[57] =
                "Не всегда чем больше в памяти страничных кадров, тем реже будут иметь место page faults. Как установил Билэди с коллегами, определенные последовательности обращений к страницам в действительности приводят к увеличению числа страничных нарушений при увеличении кадров, выделенных процессу. Это явление носит название «аномалии Билэди» или «аномалии FIFO». \nОптимальный алгоритм (OPT) \nОдним из последствий открытия аномалии Билэди стал поиск оптимального алгоритма, который при заданной строке обращений имел бы минимальную частоту page faults среди всех других алгоритмов. Такой алгоритм был найден. Он прост: замещай страницу, которая не будет использоваться в течение самого длительного периода времени. \nКаждая страница должна быть помечена числом инструкций, которые будут выполнены, прежде чем на эту страницу будет сделана первая ссылка. Выталкиваться должна страница, для которой это число наибольшее. \nЭтот алгоритм легко описать, но реализовать невозможно. ОС не знает, к какой странице будет следующее обращение. \nМожно сделать вывод, что для того, чтобы алгоритм замещения был максимально близок к идеальному алгоритму, система должна как можно точнее предсказывать обращения процессов к памяти. Данный алгоритм применяется для оценки качества реализуемых алгоритмов. \nВыталкивание дольше всего не использовавшейся страницы. Алгоритм LRU \nЕсли использовать прошлое для аппроксимации будущего, имеет смысл замещать страницу, которая не использовалась в течение самого долгого времени. Такой подход называется least recently used алгоритм (LRU ). \nОн хороший, но труднореализуемый. Необходимо иметь связанный список всех страниц в памяти, в начале которого будут хранится недавно использованные страницы. Он должен обновляться при каждом обращении к памяти. Много времени нужно и на поиск страниц в таком списке. \nКак оптимальный алгоритм, так и LRU не страдают от аномалии Билэди. Существует класс алгоритмов, для которых при одной и той же строке обращений множество страниц в памяти для n кадров всегда является подмножеством страниц для n+1 кадра. Эти алгоритмы не проявляют аномалии Билэди и называются стековыми алгоритмами."
            answer[58] =
                "Программная реализация алгоритма, близкого к LRU, - алгоритм NFU (Not Frequently Used). \nДля него требуются программные счетчики, по одному на каждую страницу, которые сначала равны нулю. При каждом прерывании по времени ОС сканирует все страницы в памяти и у каждой страницы с установленным флагом обращения увеличивает на единицу значение счетчика, а флаг обращения сбрасывает. \nКандидатом на освобождение оказывается страница с наименьшим значением счетчика, как страница, к которой реже всего обращались. Главный недостаток алгоритма NFU состоит в том, что он ничего не забывает. Например, страница, к которой очень часто обращались в течение некоторого времени, а потом обращаться перестали, все равно не будет удалена из памяти, потому что ее счетчик содержит большую величину. Например, в многопроходных компиляторах страницы, которые активно использовались во время первого прохода, могут надолго сохранить большие значения счетчика, мешая загрузке полезных в дальнейшем страниц. \nВозможна небольшая модификация алгоритма, которая позволяет ему «забывать». Достаточно, чтобы при каждом прерывании по времени содержимое счетчика сдвигалось вправо на 1 бит, а уже затем производилось бы его увеличение для страниц с установленным флагом обращения. \nДругим, уже более устойчивым недостатком алгоритма является длительность процесса сканирования таблиц страниц. \nТрешинг (Thrashing) – концепция рабочего множества. \nХотя теоретически возможно уменьшить число кадров процесса до минимума, существует какое-то число активно используемых страниц, без которого процесс часто генерирует page faults.  Высокая частота страничных нарушений называется трешинг. Процесс находится в состоянии трешинга, если при его работе больше времени уходит на подкачку страниц, нежели на выполнение команд. Такого рода критическая ситуация возникает вне зависимости от конкретных алгоритмов замещения. \nЧасто результатом трешинга является снижение производительности вычислительной системы. Один из нежелательных сценариев развития событий может выглядеть следующим образом. При глобальном алгоритме замещения процесс, которому не хватает кадров, начинает отбирать кадры у других процессов, которые в свою очередь начинают заниматься тем же. В результате все процессы попадают в очередь запросов к устройству вторичной памяти (находятся в состоянии ожидания), а очередь процессов в состоянии готовности пустеет. Загрузка процессора снижается. ОС реагирует на это увеличением степени мультипрограммирования, что приводит к еще большему трешингу и дальнейшему снижению загрузки процессора. Таким образом, пропускная способность системы падает из-за трешинга. \nТрешинг - высокая частота страничных нарушений. Hеобходимо ее контролировать. Когда она высока, процесс нуждается в кадрах. Можно, устанавливая желаемую частоту page faults, регулировать размер процесса, добавляя или отнимая у него кадры. Может оказаться целесообразным выгрузить процесс целиком. Освободившиеся кадры выделяются другим процессам с высокой частотой page faults."
            answer[59] =
                "Процессы начинают работать, не имея в памяти необходимых страниц. В результате при выполнении первой же машинной инструкции возникает page fault, требующий подкачки порции кода. Следующий page fault происходит при локализации глобальных переменных и еще один - при выделении памяти для стека. После того как процесс собрал большую часть необходимых ему страниц, page faults возникают редко. \nТаким образом, существует набор страниц (P1, P2, ... Pn), активно использующихся вместе, который позволяет процессу в момент времени t в течение некоторого периода T производительно работать, избегая большого количества page faults. Этот набор страниц называется рабочим множеством W(t,T) процесса. Число страниц в рабочем множестве определяется параметром Т, является неубывающей функцией T и относительно невелико. Иногда T называют размером окна рабочего множества, через которое ведется наблюдение за процессом. \nНаиболее важное свойство рабочего множества - его размер. ОС должна выделить каждому процессу достаточное число кадров, чтобы поместилось его рабочее множество. Если кадры еще остались, то может быть инициирован другой процесс. Если рабочие множества процессов не помещаются в память и начинается трешинг, то один из процессов можно выгрузить на диск. \nСтраничные демоны: \nПодсистема виртуальной памяти работает производительно при наличии резерва свободных страничных кадров. Алгоритмы, обеспечивающие поддержку системы в состоянии отсутствия трешинга, реализованы в составе фоновых процессов (их часто называют демонами или сервисами), которые периодически «просыпаются» и инспектируют состояние памяти. Если свободных кадров оказывается мало, они могут сменить стратегию замещения. Их задача - поддерживать систему в состоянии наилучшей производительности."
            answer[60] =
                "Чаще всеговиртуальная память процесса ОС разбивается на сегменты пяти типов: кода программы, данных, стека, разделяемый и сегмент файлов, отображаемых в память. Сегмент программного кода содержит только команды. \nСегмент программного кода не модифицируется в ходе выполнения процесса, обычно страницы данного сегмента имеют атрибут read-only. Следствием этого является возможность использования одного экземпляра кода для разных процессов. \nСегмент данных, с о д е р ж а щ и й  п е р е м е н н ы е  п р о г р а м м ы  и  с е г м е н т  с т е к а, содержащий автоматические переменные, могут динамически менять свой размер (обычно данные в сторону увеличения адресов, а стек - в сторону уменьшения) и содержимое, должны быть доступны по чтению и записи и являются приватными сегментами процесса. \nС целью обобществления памяти между несколькими процессами создаются разделяемые сегменты, допускающие доступ по чтению и записи. Вариантом разделяемого сегмента может быть сегмент файла, отображаемого в память. Специфика таких сегментов состоит в том, что из них откачка осуществляется не в системную область выгрузки, а непосредственно в отображаемый файл. Реализация разделяемых сегментов основана на том, что логические страницы различных процессов связываются с одними и теми же страничными кадрами. \nСегменты представляют собой непрерывные области в виртуальном адресном пространстве процесса, выровненные по границам страниц. Каждая область состоит из набора страниц с одним и тем же режимом защиты. Между областями в виртуальном пространстве могут быть свободные участки. \nЧасть работы по организации сегментов может происходить с участием программиста. Особенно это заметно при низкоуровневом программировании. В частности, отдельные области памяти могут быть поименованы и использоваться для обмена данными между процессами. Два процесса могут общаться через разделяемую область памяти при условии, что им известно ее имя (пароль). Обычно это делается при помощи специальных вызовов (например, map и unmap), входящих в состав интерфейса виртуальной памяти."
            answer[61] =
                "Корректная работа менеджера памяти помимо принципиальных вопросов, связанных с выбором абстрактной модели виртуальной памяти и ее аппаратной поддержкой, обеспечивается также множеством нюансов и мелких деталей. Локализация страниц в памяти применяется, когда поддержка страничной системы приводит к необходимости разрешить определенным страницам, хранящим буферы ввода-вывода, другие важные данные и код, быть блокированными в памяти. \nСистема виртуальной памяти может вступить в конфликт с подсистемой ввода-вывода. Например, процесс может запросить ввод в буфер и ожидать его завершения. Управление передастся другому процессу, который может вызвать page fault и, с отличной от нуля вероятностью, спровоцировать выгрузку той страницы, куда должен быть осуществлен ввод первым процессом. Подобные ситуации нуждаются в дополнительном контроле, особенно если ввод-вывод реализован с использованием механизма прямого доступа к памяти (DMA). Одно из решений даннойпроблемы - вводить данные в не вытесняемый буфер в пространстве ядра, а затем копировать их в пользовательское пространство. \nВторое решение - локализовать страницы в памяти, используя специальный бит локализации, входящий в состав атрибутов страницы. Локализованная страница замещению не подлежит. Бит локализации сбрасывается после завершения операции ввода/вывода. \nДругим важным применением локализации является ее использование в системах мягкого реального времени. Рассмотрим процесс или нить реального времени. Вообще говоря, виртуальная память - антитеза вычислений реального времени, так как дает непредсказуемые задержки при подкачке страниц. \nПоэтому системы реального времени почти не используют виртуальную память. ОС Solaris поддерживает как реальное время, так и разделение времени. Для решения проблемы page faults, Solaris разрешает процессам сообщать системе, какие страницы важны для процесса, и локализовать их в памяти. В результате возможно выполнение процесса, реализующего задачу реального времени, содержащего локализованные страницы, где временные задержки страничной системы будут минимизированы. \nЕсть другие проблемы, возникающие в процессе управления памятью. Так, например, бывает непросто осуществить повторное выполнение инструкции, вызвавшей page fault. Представляют интерес и алгоритмы отложенного выделения памяти (копирование при записи и др.)."
            answer[62] =
                "После успешной регистрации система должна осуществлять авторизацию - предоставление субъекту прав на доступ к объекту. Средства авторизации контролируют доступ легальных пользователей к ресурсам системы, предоставляя каждому из них именно те права, которые были определены администратором, а также осуществляют контроль возможности выполнения пользователем различных системных функций. Система контроля базируется на общей модели, называемой матрицей доступа. \nР а з л и ч а ю т  дискреционный ( избирательный ) способ управления доступом и полномочный (мандатный). \nПри дискреционном доступе, определенные операции над конкретным ресурсом запрещаются или разрешаются субъектам или группам субъектов. С концептуальной точки зрения, текущее состояние прав доступа при дискреционном управлении описывается матрицей, в строках которой перечислены субъекты, в столбцах - объекты, а в ячейках - операции, которые субъект может выполнить над объектом. \nПолномочный подход заключается в том, что все объекты могут иметь уровни секретности, а все субъекты делятся на группы, образующие иерархию в соответствии с уровнем допуска к информации. Иногда это называют моделью многоуровневой безопасности, которая должна обеспечивать выполнение следующих правил: \n• Простое свойство секретности. Субъект может читать информацию только из объекта, уровень секретности которого не выше уровня секретности субъекта. Генерал читает документы лейтенанта, но не наоборот; \n• *-свойство. Субъект может записывать информацию в объекты только своего уровня или более высоких уровней секретности. Генерал не может случайно разгласить нижним чинам секретную информацию. \nБольшинство ОС реализуют именно дискреционное управление доступом. Главное его достоинство - гибкость, основные недостатки - рассредоточенность управления и сложность централизованного контроля."
            answer[63] =
                "Чтобы рассмотреть схему дискреционного доступа более детально, введем концепцию домена безопасности. Каждый домен определяет набор объектов и типов операций, которые могут производиться над каждым объектом. Возможность выполнять операции над объектом есть права доступа, каждое из которых есть упорядоченная пара . Домен есть набор прав доступа. Hапример, если домен D имеет права доступа , это означает, что процесс, выполняемый в домене D, может читать или писать в файл F, но не может выполнять других операций над этим объектом. \nСвязь конкретных субъектов, функционирующих в ОС, может быть организована следующим образом: \n• Каждый пользователь может быть доменом. В этом случае набор объектов, к которым может быть организован доступ, зависит от идентификации пользователя; \n• Каждый процесс может быть доменом. В этом случае набор доступных объектов определяется идентификацией процесса; \n• Каждая процедура может быть доменом. В этом случае набор доступных объектов соответствует локальным переменным, определенным внутри процедуры. Когда процедура выполнена, происходит смена домена. \nРассмотрим стандартную двухрежимную модель выполнения ОС. Когда процесс выполняется в режиме системы (kernel mode), он может выполнять привилегированные инструкции и иметь полный контроль над компьютерной системой. С другой стороны, если процесс выполняется в пользовательском режиме, он может вызывать только непривилегированные инструкции. Следовательно, он может выполняться только внутри предопределенного пространства памяти. Наличие этих двух режимов позволяет защитить ОС (kernel domain) от пользовательских процессов (выполняющихся в user domain). В мультипрограммных системах двух доменов недостаточно, так как появляется необходимость защиты."

            quest[0] = "Большинство современных компьютеров состоит из двух и более уровней."
            quest[1] =
                "Принципиально важными универсальными подходами к разработке архитектуры ОС являются."
            quest[2] = "В современных операционных системах различают следующие виды ядер. "
            quest[3] = "К ОС предъявляется ряд важных эксплуатационных требований."
            quest[4] =
                "Концепция процессов и потоков. Задание, процессы, потоки (нити), волокна. Методы взаимоисключений."
            quest[5] = "Управление процессами и потоками. Взаимоблокировки. "
            quest[6] = "Планирование заданий, процессов и потоков."
            quest[7] = "Организация памяти современного компьютера."
            quest[8] = "Распределение памяти."
            quest[9] = "Оптимизация функционирования страничной виртуальной памяти."
            quest[10] = "Назначение операционных систем."
            quest[11] =
                "Многослойная структура ядра ОС может быть представлена, например, вариантом, показанным(кольцо)."
            quest[12] =
                "Все многообразие существующих (и ныне не использующихся) ОС можно классифицировать по множеству различных признаков."
            quest[13] = "Эффекты виртуализации."
            quest[14] =
                "Мультипрограммирование. Формы многопрограммной работы. Семафоры и мониторы. "
            quest[15] =
                "Создание процессов и потоков. Модели процессов и потоков. Системные вызовы."
            quest[16] = "Взаимодействие и синхронизация процессов и потоков."
            quest[17] = "Функции ОС по управлению памятью. "
            quest[18] = "Страничная организация виртуальной памяти."
            quest[19] = "Сегментная организация виртуальной памяти."
            quest[20] = "Назначение, задачи и технологии подсистемы ввода-вывода."
            quest[21] = "Согласование скоростей обмена и кэширования данных."
            quest[22] = "Разделение устройств и данных между процессами."
            quest[23] =
                "Обеспечение логического интерфейса между устройствами и системой. Динамическая загрузка и выгрузка драйверов."
            quest[24] = "Поддержка широкого спектра драйверов."
            quest[25] = "Поддержка синхронных и асинхронных операций ввода-вывода."
            quest[26] = "Многослойная (иерархическая) модель подсистемы ввода-вывода. "
            quest[27] = "Драйверы."
            quest[28] = "Файловые системы. Основные понятия."
            quest[29] = "Архитектура файловой системы."
            quest[30] = "Организация файлов и доступ к ним."
            quest[31] = "Каталоговые системы."
            quest[32] = "Физическая организация файловой системы."
            quest[33] = "Физическая организация и адресация файла."
            quest[34] = "Физическая организация FAT-системы."
            quest[35] = "Файловые операции."
            quest[36] = "Контроль доступа к файлам."
            quest[37] = "Уровни планирования."
            quest[38] = "Критерии планирования и требования к алгоритмам."
            quest[39] = "Параметры планирования."
            quest[40] = "Вытесняющее и невытесняющее планирование."
            quest[41] = "First-Come, First-Served (FCFS)."
            quest[42] = "Round Robin (RR)."
            quest[43] = "Shortest-Job-First (SJF)."
            quest[44] = "Гарантированное планирование."
            quest[45] = "Приоритетное планирование."
            quest[46] = "Многоуровневые очереди (Multilevel Queue)"
            quest[47] = "Взаимодействующие процессы."
            quest[48] =
                " Категории средств обмена информацией. Логическая организация механизма передачи информации."
            quest[49] = "Нити исполнения."
            quest[50] = "Interleaving, race condition и взаимоисключения."
            quest[51] = "Критическая секция."
            quest[52] = "Программные алгоритмы организации взаимодействия процессов. "
            quest[53] = "Запрет прерываний. Переменная-замок. Строгое чередование."
            quest[54] =
                "Флаги готовности. Алгоритм Петерсона. Алгоритм булочной (Bakery algorithm). Аппаратная поддержка взаимоисключений."
            quest[55] =
                "Команда Test-and-Set (проверить и присвоить 1). Команда Swap (обменять значения)."
            quest[56] = "Исключительные ситуации при работе с памятью."
            quest[57] =
                "Аномалия Билэди (Belady). Оптимальный алгоритм (OPT). Выталкивание дольше всего не использовавшейся страницы. Алгоритм LRU."
            quest[58] =
                "Выталкивание редко используемой страницы. Алгоритм NFU. Трешинг (Thrashing)."
            quest[59] = "Модель рабочего множества. Страничные демоны."
            quest[60] = "Программная поддержка сегментной модели памяти процесса."
            quest[61] = "Отдельные аспекты функционирования менеджера памяти."
            quest[62] = "Авторизация. Разграничение доступа к объектам ОС."
            quest[63] = "Домены безопасности."
        }
        2 -> {
            answer[0] = "В истории становления этой науки можно выделить три основных периода: \n" +
                    "1.\tзарождение экономической мысли; \n" +
                    "2.\tпоявление экономики как науки, формирование экономических школ; \n" +
                    "3.\tраскол классической модели экономики, формирование современного взгляда на экономику.\n" +
                    "Первый этап. Экономическая мысль зарождалась и в странах Древней Греции и Рима. Трактаты Платона, Ксенофонта и Аристотеля — древнегреческих философов, современные ученые называют истоками экономики как науки в нашем понимании. В них были заложены основы экономического анализа. В своих исследованиях мыслители стремились рационализировать затраты на содержание домашнего хозяйства. \n" +
                    "Второй этап-экономические школы.\n" +
                    "Выделяют следующие основные направления: \n" +
                    "Меркантилизм (XVI-XVII), яркий представитель – Томас Манн. Основой богатства меркантилисты считали торговлю, а уровень богатства населения измеряли количеством золота, поступавшим в страну. Таким образом, самой перспективной деятельностью считалась внешняя торговля, производство товара на экспорт. При этом они пропагандировали необходимость «защищать» собственный рынок от избытка ввозимых товаров. \n" +
                    "Физиократия стала второй крупной экономической школой (в XVIII веке) Известнейшие представители — Ф. Кенэ, А. Тюрго. Они продвигали интересы землевладельцев, утверждая, что самый надежный источник прибыли — сельское хозяйство.\n" +
                    " Представители классической экономической школы — У. Петти, А. Смит, Д. Рикардо считали производство основой экономики. Они придерживались принципа либерализма, то есть исключались вмешательства государства в экономическую систему, она должна была устанавливаться самостоятельно, на основе своих законов (Либерализм)\n" +
                    "Третий этап \n" +
                    "Начиная с середины XIX века представление об идеальной экономической системе кардинально менялось. На третьем этапе формирования экономики как науки можно выделить направления:( Марксизм, монетаризм, институционализм, неокейнсианство, маржинализм)\n" +
                    "\n"
            answer[1] = "Можно выделить 3 основных направления экономической мысли: \n" +
                    "1) неоклассическое\n" +
                    "2) кейнсианское\n" +
                    "3) институционально-социологическое.\n" +
                    "Представителями неоклассического направления являются Менгер, Визер.\n" +
                    "Неокласическое направление представлено следующими теориями:\n" +
                    "1) Маржинализм - это теория представляющая экономику как систему взаимосвязанных хозяйствующих субъектов и объясняющие экономические процессы и явления, исходя из новой идеи исполнения предельных крайних величин, кот. хар-ет не сущность явления, а их изменения в связи с изменением др. явлений и процессов. (маржиналисты заменили качественный экономический анализ количественным. Ученые стремятся оптимизировать использование ограниченных ресурсов) Главная категория – предельная полезность, пред-е издержки. Маржинализм опирается на полит-ий анализ и использует экономико-математич-е модели, в основе кот-х лежат субъективные оценки.\n" +
                    "2) Монетаризм –теория стабилизации экономики, в которой главенствующую роль играют денежные факторы. Монетаристы сводят управление экономикой прежде всего к контролю государства над денежной массой эмиссией денег, количеством денег, находящимся в обращении или запасах. Достижению сбалансированности государственного бюджета и установлению высокого банковского процента.\n" +
                    "3) Неолиберализм –это течение согласно которому необходимо сокращать вмешательство государства в экономику, ибо частное предпринимательство способно вывести экономику из кризиса и обеспечить ее подъем и благосостояние населения. Отсюда важно предоставление максимально возможной свободы предпринимателям и торговцам в хозяйственной деятельности.\n" +
                    "Кейнсианское направление ставило в центр внимания проблемы макроэкономики, изучающей экономику как единое целое, как крупную систему. Кейнс констатировал, что основой успешного функционирования экономики является формирование эффективного спроса и факторов, влияющих на его изменение\n" +
                    "\n"
            answer[2] = ""

            quest[0] = "Основные этапы развития экономики."
            quest[1] = "Основные направления экономической мысли."
            quest[2] = ""
        }
        3 -> {
            //TODO ДОПИЛИТЬ ФИЛОСОФИЮ
        }
    }
}
